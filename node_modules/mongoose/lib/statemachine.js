/*!
 * Module dependencies.
 */
var utils=require("./utils"),StateMachine=module.exports=exports=function(){};/*!
 * StateMachine.ctor('state1', 'state2', ...)
 * A factory method for subclassing StateMachine.
 * The arguments are a list of states. For each state,
 * the constructor's prototype gets state transition
 * methods named after each state. These transition methods
 * place their path argument into the given state.
 *
 * @param {String} state
 * @param {String} [state]
 * @return {Function} subclass constructor
 * @private
 */
StateMachine.ctor=function(){var t=utils.args(arguments),e=function(){StateMachine.apply(this,arguments),this.paths={},this.states={},this.stateNames=t;for(var e,a=t.length;a--;)e=t[a],this.states[e]={}};return e.prototype=new StateMachine,t.forEach(function(t){e.prototype[t]=function(e){this._changeState(e,t)}}),e},/*!
 * This function is wrapped by the state change functions:
 *
 * - `require(path)`
 * - `modify(path)`
 * - `init(path)`
 *
 * @api private
 */
StateMachine.prototype._changeState=function(t,e){var a=this.states[this.paths[t]];a&&delete a[t],this.paths[t]=e,this.states[e][t]=!0},/*!
 * ignore
 */
StateMachine.prototype.clear=function(t){for(var e,a=Object.keys(this.states[t]),s=a.length;s--;)e=a[s],delete this.states[t][e],delete this.paths[e]},/*!
 * Checks to see if at least one path is in the states passed in via `arguments`
 * e.g., this.some('required', 'inited')
 *
 * @param {String} state that we want to check for.
 * @private
 */
StateMachine.prototype.some=function(){var t=this,e=arguments.length?arguments:this.stateNames;return Array.prototype.some.call(e,function(e){return Object.keys(t.states[e]).length})},/*!
 * This function builds the functions that get assigned to `forEach` and `map`,
 * since both of those methods share a lot of the same logic.
 *
 * @param {String} iterMethod is either 'forEach' or 'map'
 * @return {Function}
 * @api private
 */
StateMachine.prototype._iter=function(t){return function(){var e=arguments.length,a=utils.args(arguments,0,e-1),s=arguments[e-1];a.length||(a=this.stateNames);var n=this,r=a.reduce(function(t,e){return t.concat(Object.keys(n.states[e]))},[]);return r[t](function(t,e,a){return s(t,e,a)})}},/*!
 * Iterates over the paths that belong to one of the parameter states.
 *
 * The function profile can look like:
 * this.forEach(state1, fn);         // iterates over all paths in state1
 * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2
 * this.forEach(fn);                 // iterates over all paths in all states
 *
 * @param {String} [state]
 * @param {String} [state]
 * @param {Function} callback
 * @private
 */
StateMachine.prototype.forEach=function(){return this.forEach=this._iter("forEach"),this.forEach.apply(this,arguments)},/*!
 * Maps over the paths that belong to one of the parameter states.
 *
 * The function profile can look like:
 * this.forEach(state1, fn);         // iterates over all paths in state1
 * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2
 * this.forEach(fn);                 // iterates over all paths in all states
 *
 * @param {String} [state]
 * @param {String} [state]
 * @param {Function} callback
 * @return {Array}
 * @private
 */
StateMachine.prototype.map=function(){return this.map=this._iter("map"),this.map.apply(this,arguments)};