<h1 id="jsprim-utilities-for-primitive-javascript-types">jsprim: utilities for primitive JavaScript types</h1>

<p>This module provides miscellaneous facilities for working with strings,
numbers, dates, and objects and arrays of these basic types.</p>

<h3 id="deepcopy-obj">deepCopy(obj)</h3>

<p>Creates a deep copy of a primitive type, object, or array of primitive types.</p>

<h3 id="deepequal-obj1-obj2">deepEqual(obj1, obj2)</h3>

<p>Returns whether two objects are equal.</p>

<h3 id="isempty-obj">isEmpty(obj)</h3>

<p>Returns true if the given object has no properties and false otherwise.  This
is O(1) (unlike <code class="prettyprint">Object.keys(obj).length === 0</code>, which is O(N)).</p>

<h3 id="haskey-obj-key">hasKey(obj, key)</h3>

<p>Returns true if the given object has an enumerable, non-inherited property
called <code class="prettyprint">key</code>.  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties">For information on enumerability and ownership of properties, see
the MDN
documentation.</a></p>

<h3 id="foreachkey-obj-callback">forEachKey(obj, callback)</h3>

<p>Like Array.forEach, but iterates enumerable, owned properties of an object
rather than elements of an array.  Equivalent to:</p>

<p>for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    callback(key, obj[key]);
            }
    }</p>

<h3 id="flattenobject-obj-depth">flattenObject(obj, depth)</h3>

<p>Flattens an object up to a given level of nesting, returning an array of arrays
of length &ldquo;depth + 1&rdquo;, where the first &ldquo;depth&rdquo; elements correspond to flattened
columns and the last element contains the remaining object .  For example:</p>

<p>flattenObject({
        &lsquo;I&rsquo;: {
            &#39;A&rsquo;: {
                &#39;i&rsquo;: {
                    &#39;datum1&rsquo;: [ 1, 2 ],
                    &#39;datum2&rsquo;: [ 3, 4 ]
                },
                &#39;ii&rsquo;: {
                    &#39;datum1&rsquo;: [ 3, 4 ]
                }
            },
            &#39;B&rsquo;: {
                &#39;i&rsquo;: {
                    &#39;datum1&rsquo;: [ 5, 6 ]
                },
                &#39;ii&rsquo;: {
                    &#39;datum1&rsquo;: [ 7, 8 ],
                    &#39;datum2&rsquo;: [ 3, 4 ],
                },
                &#39;iii&rsquo;: {
                }
            }
        },
        &#39;II&rsquo;: {
            &#39;A&rsquo;: {
                &#39;i&rsquo;: {
                    &#39;datum1&rsquo;: [ 1, 2 ],
                    &#39;datum2&rsquo;: [ 3, 4 ]
                }
            }
        }
    }, 3)</p>

<p>becomes:</p>

<p>[
        [ &#39;I&rsquo;,  &#39;A&rsquo;, &#39;i&rsquo;,   { &#39;datum1&rsquo;: [ 1, 2 ], &#39;datum2&rsquo;: [ 3, 4 ] } ],
        [ &#39;I&rsquo;,  &#39;A&rsquo;, &#39;ii&rsquo;,  { &#39;datum1&rsquo;: [ 3, 4 ] } ],
        [ &#39;I&rsquo;,  &#39;B&rsquo;, &#39;i&rsquo;,   { &#39;datum1&rsquo;: [ 5, 6 ] } ],
        [ &#39;I&rsquo;,  &#39;B&rsquo;, &#39;ii&rsquo;,  { &#39;datum1&rsquo;: [ 7, 8 ], &#39;datum2&rsquo;: [ 3, 4 ] } ],
        [ &#39;I&rsquo;,  &#39;B&rsquo;, &#39;iii&rsquo;, {} ],
        [ &#39;II&rsquo;, &#39;A&rsquo;, &#39;i&rsquo;,   { &#39;datum1&rsquo;: [ 1, 2 ], &#39;datum2&rsquo;: [ 3, 4 ] } ]
    ]</p>

<p>This function is strict: &ldquo;depth&rdquo; must be a non-negative integer and &ldquo;obj&rdquo; must
be a non-null object with at least &ldquo;depth&rdquo; levels of nesting under all keys.</p>

<h3 id="flatteniter-obj-depth-func">flattenIter(obj, depth, func)</h3>

<p>This is similar to <code class="prettyprint">flattenObject</code> except that instead of returning an array,
this function invokes <code class="prettyprint">func(entry)</code> for each <code class="prettyprint">entry</code> in the array that
<code class="prettyprint">flattenObject</code> would return.  <code class="prettyprint">flattenIter(obj, depth, func)</code> is logically
equivalent to <code class="prettyprint">flattenObject(obj, depth).forEach(func)</code>.  Importantly, this
version never constructs the full array.  Its memory usage is O(depth) rather
than O(n) (where <code class="prettyprint">n</code> is the number of flattened elements).</p>

<p>There&rsquo;s another difference between <code class="prettyprint">flattenObject</code> and <code class="prettyprint">flattenIter</code> that&rsquo;s
related to the special case where <code class="prettyprint">depth === 0</code>.  In this case, <code class="prettyprint">flattenObject</code>
omits the array wrapping <code class="prettyprint">obj</code> (which is regrettable).</p>

<h3 id="pluck-obj-key">pluck(obj, key)</h3>

<p>Fetch nested property &ldquo;key&rdquo; from object &ldquo;obj&rdquo;, traversing objects as needed.
For example, <code class="prettyprint">pluck(obj, &quot;foo.bar.baz&quot;)</code> is roughly equivalent to
<code class="prettyprint">obj.foo.bar.baz</code>, except that:</p>

<ol>
<li>If traversal fails, the resulting value is undefined, and no error is
thrown.  For example, <code class="prettyprint">pluck({}, &quot;foo.bar&quot;)</code> is just undefined.</li>
<li>If &ldquo;obj&rdquo; has property &ldquo;key&rdquo; directly (without traversing), the
corresponding property is returned.  For example,
<code class="prettyprint">pluck({ &#39;foo.bar&#39;: 1 }, &#39;foo.bar&#39;)</code> is 1, not undefined.  This is also
true recursively, so <code class="prettyprint">pluck({ &#39;a&#39;: { &#39;foo.bar&#39;: 1 } }, &#39;a.foo.bar&#39;)</code> is
also 1, not undefined.</li>
</ol>

<h3 id="randelt-array">randElt(array)</h3>

<p>Returns an element from &ldquo;array&rdquo; selected uniformly at random.  If &ldquo;array&rdquo; is
empty, throws an Error.</p>

<h3 id="startswith-str-prefix">startsWith(str, prefix)</h3>

<p>Returns true if the given string starts with the given prefix and false
otherwise.</p>

<h3 id="endswith-str-suffix">endsWith(str, suffix)</h3>

<p>Returns true if the given string ends with the given suffix and false
otherwise.</p>

<h3 id="iso8601-date">iso8601(date)</h3>

<p>Converts a Date object to an ISO8601 date string of the form
&ldquo;YYYY-MM-DDTHH:MM:SS.sssZ&rdquo;.  This format is not customizable.</p>

<h3 id="parsedatetime-str">parseDateTime(str)</h3>

<p>Parses a date expressed as a string, as either a number of milliseconds since
the epoch or any string format that Date accepts, giving preference to the
former where these two sets overlap (e.g., strings containing small numbers).</p>

<h3 id="hrtimediff-timea-timeb">hrtimeDiff(timeA, timeB)</h3>

<p>Given two hrtime readings (as from Node&rsquo;s <code class="prettyprint">process.hrtime()</code>), where timeA is
later than timeB, compute the difference and return that as an hrtime.  It is
illegal to invoke this for a pair of times where timeB is newer than timeA.</p>

<h3 id="hrtimeadd-timea-timeb">hrtimeAdd(timeA, timeB)</h3>

<p>Add two hrtime intervals (as from Node&rsquo;s <code class="prettyprint">process.hrtime()</code>), returning a new
hrtime interval array.  This function does not modify either input argument.</p>

<h3 id="hrtimeaccum-timea-timeb">hrtimeAccum(timeA, timeB)</h3>

<p>Add two hrtime intervals (as from Node&rsquo;s <code class="prettyprint">process.hrtime()</code>), storing the
result in <code class="prettyprint">timeA</code>.  This function overwrites (and returns) the first argument
passed in.</p>

<h3 id="hrtimenanosec-timea-hrtimemicrosec-timea-hrtimemillisec-timea">hrtimeNanosec(timeA), hrtimeMicrosec(timeA), hrtimeMillisec(timeA)</h3>

<p>This suite of functions converts a hrtime interval (as from Node&rsquo;s
<code class="prettyprint">process.hrtime()</code>) into a scalar number of nanoseconds, microseconds or
milliseconds.  Results are truncated, as with <code class="prettyprint">Math.floor()</code>.</p>

<h3 id="validatejsonobject-schema-object">validateJsonObject(schema, object)</h3>

<p>Uses JSON validation (via JSV) to validate the given object against the given
schema.  On success, returns null.  On failure, <em>returns</em> (does not throw) a
useful Error object.</p>

<h3 id="extraproperties-object-allowed">extraProperties(object, allowed)</h3>

<p>Check an object for unexpected properties.  Accepts the object to check, and an
array of allowed property name strings.  If extra properties are detected, an
array of extra property names is returned.  If no properties other than those
in the allowed list are present on the object, the returned array will be of
zero length.</p>

<h3 id="mergeobjects-provided-overrides-defaults">mergeObjects(provided, overrides, defaults)</h3>

<p>Merge properties from objects &ldquo;provided&rdquo;, &ldquo;overrides&rdquo;, and &ldquo;defaults&rdquo;.  The
intended use case is for functions that accept named arguments in an &ldquo;args&rdquo;
object, but want to provide some default values and override other values.  In
that case, &ldquo;provided&rdquo; is what the caller specified, &ldquo;overrides&rdquo; are what the
function wants to override, and &ldquo;defaults&rdquo; contains default values.</p>

<p>The function starts with the values in &ldquo;defaults&rdquo;, overrides them with the
values in &ldquo;provided&rdquo;, and then overrides those with the values in &ldquo;overrides&rdquo;.
For convenience, any of these objects may be falsey, in which case they will be
ignored.  The input objects are never modified, but properties in the returned
object are not deep-copied.</p>

<p>For example:</p>

<p>mergeObjects(undefined, { &#39;objectMode&rsquo;: true }, { &#39;highWaterMark&rsquo;: 0 })</p>

<p>returns:</p>

<p>{ &#39;objectMode&rsquo;: true, &#39;highWaterMark&rsquo;: 0 }</p>

<p>For another example:</p>

<p>mergeObjects(
        { &#39;highWaterMark&rsquo;: 16, &#39;objectMode&rsquo;: 7 }, /* from caller <em>/
        { &#39;objectMode&rsquo;: true },                   /</em> overrides <em>/
        { &#39;highWaterMark&rsquo;: 0 });                  /</em> default */</p>

<p>returns:</p>

<p>{ &#39;objectMode&rsquo;: true, &#39;highWaterMark&rsquo;: 16 }</p>

<h1 id="contributing">Contributing</h1>

<p>Code should be &ldquo;make check&rdquo; clean.  This target assumes that
<a href="http://github.com/davepacheco/javascriptlint">jsl</a> and
<a href="http://github.com/davepacheco/jsstyle">jsstyle</a> are on your path.</p>

<p>New tests should generally accompany new functions and bug fixes.  The tests
should pass cleanly (run tests/basic.js).</p>
