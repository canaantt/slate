<p>A light, featureful and explicit option parsing library for node.js.</p>

<p><a href="#why">Why another one? See below</a>. tl;dr: The others I&rsquo;ve tried are one of
too loosey goosey (not explicit), too big/too many deps, or ill specified.
YMMV.</p>

<p>Follow <a href="https://twitter.com/intent/user?screen_name=trentmick" target="_blank">@trentmick</a>
for updates to node-dashdash.</p>

<h1 id="install">Install</h1>

<p>npm install dashdash</p>

<h1 id="usage">Usage</h1>
<pre class="highlight javascript"><code><span class="kd">var</span> <span class="nx">dashdash</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'dashdash'</span><span class="p">);</span>

<span class="c1">// Specify the options. Minimally `name` (or `names`) and `type`</span>
<span class="c1">// must be given for each.</span>
<span class="kd">var</span> <span class="nx">options</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span>
        <span class="c1">// `names` or a single `name`. First element is the `opts.KEY`.</span>
        <span class="na">names</span><span class="p">:</span> <span class="p">[</span><span class="s1">'help'</span><span class="p">,</span> <span class="s1">'h'</span><span class="p">],</span>
        <span class="c1">// See "Option specs" below for types.</span>
        <span class="na">type</span><span class="p">:</span> <span class="s1">'bool'</span><span class="p">,</span>
        <span class="na">help</span><span class="p">:</span> <span class="s1">'Print this help and exit.'</span>
    <span class="p">}</span>
<span class="p">];</span>

<span class="c1">// Shortcut form. As called it infers `process.argv`. See below for</span>
<span class="c1">// the longer form to use methods like `.help()` on the Parser object.</span>
<span class="kd">var</span> <span class="nx">opts</span> <span class="o">=</span> <span class="nx">dashdash</span><span class="p">.</span><span class="nx">parse</span><span class="p">({</span><span class="na">options</span><span class="p">:</span> <span class="nx">options</span><span class="p">});</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"opts:"</span><span class="p">,</span> <span class="nx">opts</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"args:"</span><span class="p">,</span> <span class="nx">opts</span><span class="p">.</span><span class="nx">_args</span><span class="p">);</span>
</code></pre>

<h1 id="longer-example">Longer Example</h1>

<p>A more realistic <a href="./examples/foo.js">starter script &ldquo;foo.js&rdquo;</a> is as follows.
This also shows using <code class="prettyprint">parser.help()</code> for formatted option help.</p>
<pre class="highlight javascript"><code><span class="kd">var</span> <span class="nx">dashdash</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./lib/dashdash'</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">options</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span>
        <span class="na">name</span><span class="p">:</span> <span class="s1">'version'</span><span class="p">,</span>
        <span class="na">type</span><span class="p">:</span> <span class="s1">'bool'</span><span class="p">,</span>
        <span class="na">help</span><span class="p">:</span> <span class="s1">'Print tool version and exit.'</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="na">names</span><span class="p">:</span> <span class="p">[</span><span class="s1">'help'</span><span class="p">,</span> <span class="s1">'h'</span><span class="p">],</span>
        <span class="na">type</span><span class="p">:</span> <span class="s1">'bool'</span><span class="p">,</span>
        <span class="na">help</span><span class="p">:</span> <span class="s1">'Print this help and exit.'</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="na">names</span><span class="p">:</span> <span class="p">[</span><span class="s1">'verbose'</span><span class="p">,</span> <span class="s1">'v'</span><span class="p">],</span>
        <span class="na">type</span><span class="p">:</span> <span class="s1">'arrayOfBool'</span><span class="p">,</span>
        <span class="na">help</span><span class="p">:</span> <span class="s1">'Verbose output. Use multiple times for more verbose.'</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="na">names</span><span class="p">:</span> <span class="p">[</span><span class="s1">'file'</span><span class="p">,</span> <span class="s1">'f'</span><span class="p">],</span>
        <span class="na">type</span><span class="p">:</span> <span class="s1">'string'</span><span class="p">,</span>
        <span class="na">help</span><span class="p">:</span> <span class="s1">'File to process'</span><span class="p">,</span>
        <span class="na">helpArg</span><span class="p">:</span> <span class="s1">'FILE'</span>
    <span class="p">}</span>
<span class="p">];</span>

<span class="kd">var</span> <span class="nx">parser</span> <span class="o">=</span> <span class="nx">dashdash</span><span class="p">.</span><span class="nx">createParser</span><span class="p">({</span><span class="na">options</span><span class="p">:</span> <span class="nx">options</span><span class="p">});</span>
<span class="k">try</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">opts</span> <span class="o">=</span> <span class="nx">parser</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">argv</span><span class="p">);</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="s1">'foo: error: %s'</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
    <span class="nx">process</span><span class="p">.</span><span class="nx">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"# opts:"</span><span class="p">,</span> <span class="nx">opts</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"# args:"</span><span class="p">,</span> <span class="nx">opts</span><span class="p">.</span><span class="nx">_args</span><span class="p">);</span>

<span class="c1">// Use `parser.help()` for formatted options help.</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">opts</span><span class="p">.</span><span class="nx">help</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">help</span> <span class="o">=</span> <span class="nx">parser</span><span class="p">.</span><span class="nx">help</span><span class="p">({</span><span class="na">includeEnv</span><span class="p">:</span> <span class="kc">true</span><span class="p">}).</span><span class="nx">trimRight</span><span class="p">();</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'usage: node foo.js [OPTIONS]\n'</span>
                <span class="o">+</span> <span class="s1">'options:\n'</span>
                <span class="o">+</span> <span class="nx">help</span><span class="p">);</span>
    <span class="nx">process</span><span class="p">.</span><span class="nx">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre>

<p>Some example output from this script (foo.js):</p>
<pre class="highlight plaintext"><code>$ node foo.js -h
# opts: { help: true,
  _order: [ { name: 'help', value: true, from: 'argv' } ],
  _args: [] }
# args: []
usage: node foo.js [OPTIONS]
options:
    --version             Print tool version and exit.
    -h, --help            Print this help and exit.
    -v, --verbose         Verbose output. Use multiple times for more verbose.
    -f FILE, --file=FILE  File to process

$ node foo.js -v
# opts: { verbose: [ true ],
  _order: [ { name: 'verbose', value: true, from: 'argv' } ],
  _args: [] }
# args: []

$ node foo.js --version arg1
# opts: { version: true,
  _order: [ { name: 'version', value: true, from: 'argv' } ],
  _args: [ 'arg1' ] }
# args: [ 'arg1' ]

$ node foo.js -f bar.txt
# opts: { file: 'bar.txt',
  _order: [ { name: 'file', value: 'bar.txt', from: 'argv' } ],
  _args: [] }
# args: []

$ node foo.js -vvv --file=blah
# opts: { verbose: [ true, true, true ],
  file: 'blah',
  _order:
   [ { name: 'verbose', value: true, from: 'argv' },
     { name: 'verbose', value: true, from: 'argv' },
     { name: 'verbose', value: true, from: 'argv' },
     { name: 'file', value: 'blah', from: 'argv' } ],
  _args: [] }
# args: []
</code></pre>

<p>See the <a href="examples/">&ldquo;examples&rdquo;</a> dir for a number of starter examples using
some of dashdash&rsquo;s features.</p>

<h1 id="environment-variable-integration">Environment variable integration</h1>

<p>If you want to allow environment variables to specify options to your tool,
dashdash makes this easy. We can change the &lsquo;verbose&rsquo; option in the example
above to include an &#39;env&rsquo; field:</p>
<pre class="highlight javascript"><code>    <span class="p">{</span>
        <span class="nl">names</span><span class="p">:</span> <span class="p">[</span><span class="s1">'verbose'</span><span class="p">,</span> <span class="s1">'v'</span><span class="p">],</span>
        <span class="nx">type</span><span class="err">:</span> <span class="s1">'arrayOfBool'</span><span class="p">,</span>
        <span class="nx">env</span><span class="err">:</span> <span class="s1">'FOO_VERBOSE'</span><span class="p">,</span>         <span class="c1">// &lt;--- add this line</span>
        <span class="nx">help</span><span class="err">:</span> <span class="s1">'Verbose output. Use multiple times for more verbose.'</span>
    <span class="p">},</span>
</code></pre>

<p>then the <strong>&ldquo;FOO_VERBOSE&rdquo; environment variable</strong> can be used to set this
option:</p>
<pre class="highlight shell"><code><span class="gp">$ </span><span class="nv">FOO_VERBOSE</span><span class="o">=</span>1 node foo.js
<span class="c"># opts: { verbose: [ true ],</span>
  _order: <span class="o">[</span> <span class="o">{</span> name: <span class="s1">'verbose'</span>, value: <span class="nb">true</span>, from: <span class="s1">'env'</span> <span class="o">}</span> <span class="o">]</span>,
  _args: <span class="o">[]</span> <span class="o">}</span>
<span class="c"># args: []</span>
</code></pre>

<p>Boolean options will interpret the empty string as unset, &#39;0&rsquo; as false
and anything else as true.</p>
<pre class="highlight shell"><code><span class="gp">$ </span><span class="nv">FOO_VERBOSE</span><span class="o">=</span> node examples/foo.js                 <span class="c"># not set</span>
<span class="c"># opts: { _order: [], _args: [] }</span>
<span class="c"># args: []</span>

<span class="gp">$ </span><span class="nv">FOO_VERBOSE</span><span class="o">=</span>0 node examples/foo.js                <span class="c"># '0' is false</span>
<span class="c"># opts: { verbose: [ false ],</span>
  _order: <span class="o">[</span> <span class="o">{</span> key: <span class="s1">'verbose'</span>, value: <span class="nb">false</span>, from: <span class="s1">'env'</span> <span class="o">}</span> <span class="o">]</span>,
  _args: <span class="o">[]</span> <span class="o">}</span>
<span class="c"># args: []</span>

<span class="gp">$ </span><span class="nv">FOO_VERBOSE</span><span class="o">=</span>1 node examples/foo.js                <span class="c"># true</span>
<span class="c"># opts: { verbose: [ true ],</span>
  _order: <span class="o">[</span> <span class="o">{</span> key: <span class="s1">'verbose'</span>, value: <span class="nb">true</span>, from: <span class="s1">'env'</span> <span class="o">}</span> <span class="o">]</span>,
  _args: <span class="o">[]</span> <span class="o">}</span>
<span class="c"># args: []</span>

<span class="gp">$ </span><span class="nv">FOO_VERBOSE</span><span class="o">=</span>boogabooga node examples/foo.js       <span class="c"># true</span>
<span class="c"># opts: { verbose: [ true ],</span>
  _order: <span class="o">[</span> <span class="o">{</span> key: <span class="s1">'verbose'</span>, value: <span class="nb">true</span>, from: <span class="s1">'env'</span> <span class="o">}</span> <span class="o">]</span>,
  _args: <span class="o">[]</span> <span class="o">}</span>
<span class="c"># args: []</span>
</code></pre>

<p>Non-booleans can be used as well. Strings:</p>
<pre class="highlight shell"><code><span class="gp">$ </span><span class="nv">FOO_FILE</span><span class="o">=</span>data.txt node examples/foo.js
<span class="c"># opts: { file: 'data.txt',</span>
  _order: <span class="o">[</span> <span class="o">{</span> key: <span class="s1">'file'</span>, value: <span class="s1">'data.txt'</span>, from: <span class="s1">'env'</span> <span class="o">}</span> <span class="o">]</span>,
  _args: <span class="o">[]</span> <span class="o">}</span>
<span class="c"># args: []</span>
</code></pre>

<p>Numbers:</p>
<pre class="highlight shell"><code><span class="gp">$ </span><span class="nv">FOO_TIMEOUT</span><span class="o">=</span>5000 node examples/foo.js
<span class="c"># opts: { timeout: 5000,</span>
  _order: <span class="o">[</span> <span class="o">{</span> key: <span class="s1">'timeout'</span>, value: 5000, from: <span class="s1">'env'</span> <span class="o">}</span> <span class="o">]</span>,
  _args: <span class="o">[]</span> <span class="o">}</span>
<span class="c"># args: []</span>

<span class="gp">$ </span><span class="nv">FOO_TIMEOUT</span><span class="o">=</span>blarg node examples/foo.js
foo: error: arg <span class="k">for</span> <span class="s2">"FOO_TIMEOUT"</span> is not a positive integer: <span class="s2">"blarg"</span>
</code></pre>

<p>With the <code class="prettyprint">includeEnv: true</code> config to <code class="prettyprint">parser.help()</code> the environment
variable can also be included in <strong>help output</strong>:</p>

<p>usage: node foo.js [OPTIONS]
    options:
        &ndash;version             Print tool version and exit.
        -h, &ndash;help            Print this help and exit.
        -v, &ndash;verbose         Verbose output. Use multiple times for more verbose.
                              Environment: FOO_VERBOSE=1
        -f FILE, &ndash;file=FILE  File to process</p>

<h1 id="bash-completion">Bash completion</h1>

<p>Dashdash provides a simple way to create a Bash completion file that you
can place in your &ldquo;bash_completion.d&rdquo; directory &ndash; sometimes that is
&ldquo;/usr/local/etc/bash_completion.d/&rdquo;). Features:</p>

<ul>
<li>Support for short and long opts</li>
<li>Support for knowing which options take arguments</li>
<li>Support for subcommands (e.g. &#39;git log <TAB>&rsquo; to show just options for the
log subcommand). See
<a href="https://github.com/trentm/node-cmdln#bash-completion">node-cmdln</a> for
how to integrate that.</li>
<li>Does the right thing with &ldquo;&ndash;&rdquo; to stop options.</li>
<li>Custom optarg and arg types for custom completions.</li>
</ul>

<p>Dashdash will return bash completion file content given a parser instance:</p>

<p>var parser = dashdash.createParser({options: options});
    console.log( parser.bashCompletion({name: &#39;mycli&rsquo;}) );</p>

<p>or directly from a <code class="prettyprint">options</code> array of options specs:</p>

<p>var code = dashdash.bashCompletionFromOptions({
        name: &#39;mycli&rsquo;,
        options: OPTIONS
    });</p>

<p>Write that content to &ldquo;/usr/local/etc/bash_completion.d/mycli&rdquo; and you will
have Bash completions for <code class="prettyprint">mycli</code>. Alternatively you can write it to
any file (e.g. &ldquo;~/.bashrc&rdquo;) and source it.</p>

<p>You could add a <code class="prettyprint">--completion</code> hidden option to your tool that emits the
completion content and document for your users to call that to install
Bash completions.</p>

<p>See <a href="examples/ddcompletion.js">examples/ddcompletion.js</a> for a complete
example, including how one can define bash functions for completion of custom
option types. Also see <a href="https://github.com/trentm/node-cmdln">node-cmdln</a> for
how it uses this for Bash completion for full multi-subcommand tools.</p>

<ul>
<li>TODO: document specExtra</li>
<li>TODO: document includeHidden</li>
<li>TODO: document custom types, <code class="prettyprint">function complete\_FOO</code> guide, completionType</li>
<li>TODO: document argtypes</li>
</ul>

<h1 id="parser-config">Parser config</h1>

<p>Parser construction (i.e. <code class="prettyprint">dashdash.createParser(CONFIG)</code>) takes the
following fields:</p>

<ul>
<li><p><code class="prettyprint">options</code> (Array of option specs). Required. See the
<a href="#option-specs">Option specs</a> section below.</p></li>
<li><p><code class="prettyprint">interspersed</code> (Boolean). Optional. Default is true. If true this allows
interspersed arguments and options. I.e.:</p>

<p>node ./tool.js -v arg1 arg2 -h   # &rsquo;-h&rsquo; is after interspersed args</p></li>
</ul>

<p>Set it to false to have &rsquo;-h&rsquo; <strong>not</strong> get parsed as an option in the above
  example.</p>

<ul>
<li><p><code class="prettyprint">allowUnknown</code> (Boolean).  Optional.  Default is false.  If false, this causes
unknown arguments to throw an error.  I.e.:</p>

<p>node ./tool.js -v arg1 &ndash;afe8asefksjefhas</p></li>
</ul>

<p>Set it to true to treat the unknown option as a positional
  argument.</p>

<p><strong>Caveat</strong>: When a shortopt group, such as <code class="prettyprint">-xaz</code> contains a mix of
  known and unknown options, the <em>entire</em> group is passed through
  unmolested as a positional argument.</p>

<p>Consider if you have a known short option <code class="prettyprint">-a</code>, and parse the
  following command line:</p>

<p>node ./tool.js -xaz</p>

<p>where <code class="prettyprint">-x</code> and <code class="prettyprint">-z</code> are unknown.  There are multiple ways to
  interpret this:</p>

<p>1. <code class="prettyprint">-x</code> takes a value: <code class="prettyprint">{x: &#39;az&#39;}</code>
    2. <code class="prettyprint">-x</code> and <code class="prettyprint">-z</code> are both booleans: <code class="prettyprint">{x:true,a:true,z:true}</code></p>

<p>Since dashdash does not know what <code class="prettyprint">-x</code> and <code class="prettyprint">-z</code> are, it can&rsquo;t know
  if you&rsquo;d prefer to receive <code class="prettyprint">{a:true,_args:[&#39;-x&#39;,&#39;-z&#39;]}</code> or
  <code class="prettyprint">{x:&#39;az&#39;}</code>, or <code class="prettyprint">{_args:[&#39;-xaz&#39;]}</code>. Leaving the positional arg unprocessed
  is the easiest mistake for the user to recover from.</p>

<h1 id="option-specs">Option specs</h1>

<p>Example using all fields (required fields are noted):</p>
<pre class="highlight javascript"><code><span class="p">{</span>
    <span class="nl">names</span><span class="p">:</span> <span class="p">[</span><span class="s1">'file'</span><span class="p">,</span> <span class="s1">'f'</span><span class="p">],</span>       <span class="c1">// Required (one of `names` or `name`).</span>
    <span class="nx">type</span><span class="err">:</span> <span class="s1">'string'</span><span class="p">,</span>             <span class="c1">// Required.</span>
    <span class="nx">completionType</span><span class="err">:</span> <span class="s1">'filename'</span><span class="p">,</span>
    <span class="nx">env</span><span class="err">:</span> <span class="s1">'MYTOOL_FILE'</span><span class="p">,</span>
    <span class="nx">help</span><span class="err">:</span> <span class="s1">'Config file to load before running "mytool"'</span><span class="p">,</span>
    <span class="nx">helpArg</span><span class="err">:</span> <span class="s1">'PATH'</span><span class="p">,</span>
    <span class="nx">helpWrap</span><span class="err">:</span> <span class="kc">false</span><span class="p">,</span>
    <span class="k">default</span><span class="err">:</span> <span class="nx">path</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">HOME</span><span class="p">,</span> <span class="s1">'.mytoolrc'</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>

<p>Each option spec in the <code class="prettyprint">options</code> array must/can have the following fields:</p>

<ul>
<li><p><code class="prettyprint">name</code> (String) or <code class="prettyprint">names</code> (Array). Required. These give the option name
and aliases. The first name (if more than one given) is the key for the
parsed <code class="prettyprint">opts</code> object.</p></li>
<li><p><code class="prettyprint">type</code> (String). Required. One of:</p>

<ul>
<li>bool</li>
<li>string</li>
<li>number</li>
<li>integer</li>
<li>positiveInteger</li>
<li>date (epoch seconds, e.g. 1396031701, or ISO 8601 format
<code class="prettyprint">YYYY-MM-DD[THH:MM:SS[.sss][Z]]</code>, e.g. &ldquo;2014-03-28T18:35:01.489Z&rdquo;)</li>
<li>arrayOfBool</li>
<li>arrayOfString</li>
<li>arrayOfNumber</li>
<li>arrayOfInteger</li>
<li>arrayOfPositiveInteger</li>
<li>arrayOfDate</li>
</ul></li>
</ul>

<p>FWIW, these names attempt to match with asserts on
  <a href="https://github.com/mcavage/node-assert-plus">assert-plus</a>.
  You can add your own custom option types with <code class="prettyprint">dashdash.addOptionType</code>.
  See below.</p>

<ul>
<li><p><code class="prettyprint">completionType</code> (String). Optional. This is used for <a href="#bash-completion">Bash
completion</a> for an option argument. If not specified,
then the value of <code class="prettyprint">type</code> is used. Any string may be specified, but only the
following values have meaning:</p>

<ul>
<li><code class="prettyprint">none</code>: Provide no completions.</li>
<li><code class="prettyprint">file</code>: Bash&rsquo;s default completion (i.e. <code class="prettyprint">complete -o default</code>), which
includes filenames.</li>
<li><em>Any string FOO for which a <code class="prettyprint">function complete_FOO</code> Bash function is
defined.</em> This is for custom completions for a given tool. Typically
these custom functions are provided in the <code class="prettyprint">specExtra</code> argument to
<code class="prettyprint">dashdash.bashCompletionFromOptions()</code>. See
<a href="examples/ddcompletion.js">&ldquo;examples/ddcompletion.js&rdquo;</a> for an example.</li>
</ul></li>
<li><p><code class="prettyprint">env</code> (String or Array of String). Optional. An environment variable name
(or names) that can be used as a fallback for this option. For example,
given a &ldquo;foo.js&rdquo; like this:</p>

<p>var options = [{names: [&#39;dry-run&rsquo;, &#39;n&rsquo;], env: &#39;FOO_DRY_RUN&rsquo;}];
    var opts = dashdash.parse({options: options});</p></li>
</ul>

<p>Both <code class="prettyprint">node foo.js --dry-run</code> and <code class="prettyprint">FOO_DRY_RUN=1 node foo.js</code> would result
  in <code class="prettyprint">opts.dry_run = true</code>.</p>

<p>An environment variable is only used as a fallback, i.e. it is ignored if
  the associated option is given in <code class="prettyprint">argv</code>.</p>

<ul>
<li><p><code class="prettyprint">help</code> (String). Optional. Used for <code class="prettyprint">parser.help()</code> output.</p></li>
<li><p><code class="prettyprint">helpArg</code> (String). Optional. Used in help output as the placeholder for
the option argument, e.g. the &ldquo;PATH&rdquo; in:</p>

<p>&hellip;
    -f PATH, &ndash;file=PATH    File to process
    &hellip;</p></li>
<li><p><code class="prettyprint">helpWrap</code> (Boolean). Optional, default true. Set this to <code class="prettyprint">false</code> to have
that option&rsquo;s <code class="prettyprint">help</code> <em>not</em> be text wrapped in <code class="prettyprint">&lt;parser&gt;.help()</code> output.</p></li>
<li><p><code class="prettyprint">default</code>. Optional. A default value used for this option, if the
option isn&rsquo;t specified in argv.</p></li>
<li><p><code class="prettyprint">hidden</code> (Boolean). Optional, default false. If true, help output will not
include this option. See also the <code class="prettyprint">includeHidden</code> option to
<code class="prettyprint">bashCompletionFromOptions()</code> for <a href="#bash-completion">Bash completion</a>.</p></li>
</ul>

<h1 id="option-group-headings">Option group headings</h1>

<p>You can add headings between option specs in the <code class="prettyprint">options</code> array.  To do so,
simply add an object with only a <code class="prettyprint">group</code> property &ndash; the string to print as
the heading for the subsequent options in the array.  For example:</p>
<pre class="highlight javascript"><code><span class="kd">var</span> <span class="nx">options</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span>
        <span class="na">group</span><span class="p">:</span> <span class="s1">'Armament Options'</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="na">names</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'weapon'</span><span class="p">,</span> <span class="s1">'w'</span> <span class="p">],</span>
        <span class="na">type</span><span class="p">:</span> <span class="s1">'string'</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="na">group</span><span class="p">:</span> <span class="s1">'General Options'</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="na">names</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'help'</span><span class="p">,</span> <span class="s1">'h'</span> <span class="p">],</span>
        <span class="na">type</span><span class="p">:</span> <span class="s1">'bool'</span>
    <span class="p">}</span>
<span class="p">];</span>
<span class="p">...</span>
</code></pre>

<p>Note: You can use an empty string, <code class="prettyprint">{group: &#39;&#39;}</code>, to get a blank line in help
output between groups of options.</p>

<h1 id="help-config">Help config</h1>

<p>The <code class="prettyprint">parser.help(...)</code> function is configurable as follows:</p>

<p>Options:
          Armament Options:
        ^^  -w WEAPON, &ndash;weapon=WEAPON  Weapon with which to crush. One of: |
       /                                sword, spear, maul                  |
      /   General Options:                                                  |
     /      -h, &ndash;help                  Print this help and exit.           |
    /   ^^^^                            ^                                   |
    \       <code class="prettyprint">-- indent</code>&ndash; helpCol              maxCol &mdash;&rsquo;
     `&ndash; headingIndent</p>

<ul>
<li><code class="prettyprint">indent</code> (Number or String). Default 4. Set to a number (for that many
spaces) or a string for the literal indent.</li>
<li><code class="prettyprint">headingIndent</code> (Number or String). Default half length of <code class="prettyprint">indent</code>. Set to
a number (for that many spaces) or a string for the literal indent. This
indent applies to group heading lines, between normal option lines.</li>
<li><code class="prettyprint">nameSort</code> (String). Default is &#39;length&rsquo;. By default the names are
sorted to put the short opts first (i.e. &rsquo;-h, &ndash;help&rsquo; preferred
to &rsquo;&ndash;help, -h&rsquo;). Set to &#39;none&rsquo; to not do this sorting.</li>
<li><code class="prettyprint">maxCol</code> (Number). Default 80. Note that reflow is just done on whitespace
so a long token in the option help can overflow maxCol.</li>
<li><code class="prettyprint">helpCol</code> (Number). If not set a reasonable value will be determined
between <code class="prettyprint">minHelpCol</code> and <code class="prettyprint">maxHelpCol</code>.</li>
<li><code class="prettyprint">minHelpCol</code> (Number). Default 20.</li>
<li><code class="prettyprint">maxHelpCol</code> (Number). Default 40.</li>
<li><code class="prettyprint">helpWrap</code> (Boolean). Default true. Set to <code class="prettyprint">false</code> to have option <code class="prettyprint">help</code>
strings <em>not</em> be textwrapped to the helpCol..maxCol range.</li>
<li><code class="prettyprint">includeEnv</code> (Boolean). Default false. If the option has associated
environment variables (via the <code class="prettyprint">env</code> option spec attribute), then
append mentioned of those envvars to the help string.</li>
<li><code class="prettyprint">includeDefault</code> (Boolean). Default false. If the option has a default value
(via the <code class="prettyprint">default</code> option spec attribute, or a default on the option&rsquo;s type),
then a &ldquo;Default: VALUE&rdquo; string will be appended to the help string.</li>
</ul>

<h1 id="custom-option-types">Custom option types</h1>

<p>Dashdash includes a good starter set of option types that it will parse for
you. However, you can add your own via:</p>

<p>var dashdash = require(&#39;dashdash&rsquo;);
    dashdash.addOptionType({
        name: &rsquo;&hellip;&rsquo;,
        takesArg: true,
        helpArg: &rsquo;&hellip;&rsquo;,
        parseArg: function (option, optstr, arg) {
            &hellip;
        },
        array: false,  // optional
        arrayFlatten: false,  // optional
        default: &hellip;,   // optional
        completionType: &hellip;  // optional
    });</p>

<p>For example, a simple option type that accepts &#39;yes&rsquo;, &#39;y&rsquo;, &#39;no&rsquo; or &#39;n&rsquo; as
a boolean argument would look like:</p>

<p>var dashdash = require(&#39;dashdash&rsquo;);</p>

<p>function parseYesNo(option, optstr, arg) {
        var argLower = arg.toLowerCase()
        if (~[&#39;yes&rsquo;, &#39;y&rsquo;].indexOf(argLower)) {
            return true;
        } else if (~[&#39;no&rsquo;, &#39;n&rsquo;].indexOf(argLower)) {
            return false;
        } else {
            throw new Error(format(
                &#39;arg for &ldquo;%s&rdquo; is not &ldquo;yes&rdquo; or &ldquo;no&rdquo;: &ldquo;%s&rdquo;&rsquo;,
                optstr, arg));
        }
    }</p>

<p>dashdash.addOptionType({
        name: &#39;yesno&rsquo;
        takesArg: true,
        helpArg: &rsquo;<yes|no>&rsquo;,
        parseArg: parseYesNo
    });</p>

<p>var options = {
        {names: [&#39;answer&rsquo;, &#39;a&rsquo;], type: &#39;yesno&rsquo;}
    };
    var opts = dashdash.parse({options: options});</p>

<p>See &ldquo;examples/custom-option-*.js&rdquo; for other examples.
See the <code class="prettyprint">addOptionType</code> block comment in &ldquo;lib/dashdash.js&rdquo; for more details.
Please let me know <a href="https://github.com/trentm/node-dashdash/issues/new">with an
issue</a> if you write a
generally useful one.</p>

<h1 id="why">Why</h1>

<p>Why another node.js option parsing lib?</p>

<ul>
<li><p><code class="prettyprint">nopt</code> really is just for &ldquo;tools like npm&rdquo;. Implicit opts (e.g. &rsquo;&ndash;no-foo&rsquo;
works for every &rsquo;&ndash;foo&rsquo;). Can&rsquo;t disable abbreviated opts. Can&rsquo;t do multiple
usages of same opt, e.g. &rsquo;-vvv&rsquo; (I think). Can&rsquo;t do grouped short opts.</p></li>
<li><p><code class="prettyprint">optimist</code> has surprise interpretation of options (at least to me).
Implicit opts mean ambiguities and poor error handling for fat-fingering.
<code class="prettyprint">process.exit</code> calls makes it hard to use as a libary.</p></li>
<li><p><code class="prettyprint">optparse</code> Incomplete docs. Is this an attempted clone of Python&rsquo;s <code class="prettyprint">optparse</code>.
Not clear. Some divergence. <code class="prettyprint">parser.on(&quot;name&quot;, ...)</code> API is weird.</p></li>
<li><p><code class="prettyprint">argparse</code> Dep on underscore. No thanks just for option processing.
<code class="prettyprint">find lib | wc -l</code> -&gt; <code class="prettyprint">26</code>. Overkill.
Argparse is a bit different anyway. Not sure I want that.</p></li>
<li><p><code class="prettyprint">posix-getopt</code> No type validation. Though that isn&rsquo;t a killer. AFAIK can&rsquo;t
have a long opt without a short alias. I.e. no <code class="prettyprint">getopt_long</code> semantics.
Also, no whizbang features like generated help output.</p></li>
<li><p><a href="https://github.com/visionmedia/commander.js">&ldquo;commander.js&rdquo;</a>: I wrote
<a href="http://trentm.com/2014/01/a-critique-of-commander-for-nodejs.html">a critique</a>
a while back. It seems fine, but last I checked had
<a href="https://github.com/visionmedia/commander.js/pull/121">an outstanding bug</a>
that would prevent me from using it.</p></li>
</ul>

<h1 id="license">License</h1>

<p>MIT. See LICENSE.txt.</p>
