<h1 id="sshpk">sshpk</h1>

<p>Parse, convert, fingerprint and use SSH keys (both public and private) in pure
node &ndash; no <code class="prettyprint">ssh-keygen</code> or other external dependencies.</p>

<p>Supports RSA, DSA, ECDSA (nistp-*) and ED25519 key types, in PEM (PKCS#1, 
PKCS#8) and OpenSSH formats.</p>

<p>This library has been extracted from
<a href="https://github.com/joyent/node-http-signature"><code class="prettyprint">node-http-signature</code></a>
(work by <a href="https://github.com/mcavage">Mark Cavage</a> and
<a href="https://github.com/bahamas10">Dave Eddy</a>) and
<a href="https://github.com/bahamas10/node-ssh-fingerprint"><code class="prettyprint">node-ssh-fingerprint</code></a>
(work by Dave Eddy), with additions (including ECDSA support) by
<a href="https://github.com/arekinath">Alex Wilson</a>.</p>

<h2 id="install">Install</h2>
<pre class="highlight plaintext"><code>npm install sshpk
</code></pre>

<h2 id="examples">Examples</h2>
<pre class="highlight javascript"><code><span class="kd">var</span> <span class="nx">sshpk</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'sshpk'</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'fs'</span><span class="p">);</span>

<span class="cm">/* Read in an OpenSSH-format public key */</span>
<span class="kd">var</span> <span class="nx">keyPub</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readFileSync</span><span class="p">(</span><span class="s1">'id_rsa.pub'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">key</span> <span class="o">=</span> <span class="nx">sshpk</span><span class="p">.</span><span class="nx">parseKey</span><span class="p">(</span><span class="nx">keyPub</span><span class="p">,</span> <span class="s1">'ssh'</span><span class="p">);</span>

<span class="cm">/* Get metadata about the key */</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'type =&gt; %s'</span><span class="p">,</span> <span class="nx">key</span><span class="p">.</span><span class="nx">type</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'size =&gt; %d bits'</span><span class="p">,</span> <span class="nx">key</span><span class="p">.</span><span class="nx">size</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'comment =&gt; %s'</span><span class="p">,</span> <span class="nx">key</span><span class="p">.</span><span class="nx">comment</span><span class="p">);</span>

<span class="cm">/* Compute key fingerprints, in new OpenSSH (&gt;6.7) format, and old MD5 */</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'fingerprint =&gt; %s'</span><span class="p">,</span> <span class="nx">key</span><span class="p">.</span><span class="nx">fingerprint</span><span class="p">().</span><span class="nx">toString</span><span class="p">());</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'old-style fingerprint =&gt; %s'</span><span class="p">,</span> <span class="nx">key</span><span class="p">.</span><span class="nx">fingerprint</span><span class="p">(</span><span class="s1">'md5'</span><span class="p">).</span><span class="nx">toString</span><span class="p">());</span>
</code></pre>

<p>Example output:</p>
<pre class="highlight plaintext"><code>type =&gt; rsa
size =&gt; 2048 bits
comment =&gt; foo@foo.com
fingerprint =&gt; SHA256:PYC9kPVC6J873CSIbfp0LwYeczP/W4ffObNCuDJ1u5w
old-style fingerprint =&gt; a0:c8:ad:6c:32:9a:32:fa:59:cc:a9:8c:0a:0d:6e:bd
</code></pre>

<p>More examples: converting between formats:</p>
<pre class="highlight javascript"><code><span class="cm">/* Read in a PEM public key */</span>
<span class="kd">var</span> <span class="nx">keyPem</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readFileSync</span><span class="p">(</span><span class="s1">'id_rsa.pem'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">key</span> <span class="o">=</span> <span class="nx">sshpk</span><span class="p">.</span><span class="nx">parseKey</span><span class="p">(</span><span class="nx">keyPem</span><span class="p">,</span> <span class="s1">'pem'</span><span class="p">);</span>

<span class="cm">/* Convert to PEM PKCS#8 public key format */</span>
<span class="kd">var</span> <span class="nx">pemBuf</span> <span class="o">=</span> <span class="nx">key</span><span class="p">.</span><span class="nx">toBuffer</span><span class="p">(</span><span class="s1">'pkcs8'</span><span class="p">);</span>

<span class="cm">/* Convert to SSH public key format (and return as a string) */</span>
<span class="kd">var</span> <span class="nx">sshKey</span> <span class="o">=</span> <span class="nx">key</span><span class="p">.</span><span class="nx">toString</span><span class="p">(</span><span class="s1">'ssh'</span><span class="p">);</span>
</code></pre>

<p>Signing and verifying:</p>
<pre class="highlight javascript"><code><span class="cm">/* Read in an OpenSSH/PEM *private* key */</span>
<span class="kd">var</span> <span class="nx">keyPriv</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readFileSync</span><span class="p">(</span><span class="s1">'id_ecdsa'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">key</span> <span class="o">=</span> <span class="nx">sshpk</span><span class="p">.</span><span class="nx">parsePrivateKey</span><span class="p">(</span><span class="nx">keyPriv</span><span class="p">,</span> <span class="s1">'pem'</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="s1">'some data'</span><span class="p">;</span>

<span class="cm">/* Sign some data with the key */</span>
<span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="nx">key</span><span class="p">.</span><span class="nx">createSign</span><span class="p">(</span><span class="s1">'sha1'</span><span class="p">);</span>
<span class="nx">s</span><span class="p">.</span><span class="nx">update</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">signature</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sign</span><span class="p">();</span>

<span class="cm">/* Now load the public key (could also use just key.toPublic()) */</span>
<span class="kd">var</span> <span class="nx">keyPub</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readFileSync</span><span class="p">(</span><span class="s1">'id_ecdsa.pub'</span><span class="p">);</span>
<span class="nx">key</span> <span class="o">=</span> <span class="nx">sshpk</span><span class="p">.</span><span class="nx">parseKey</span><span class="p">(</span><span class="nx">keyPub</span><span class="p">,</span> <span class="s1">'ssh'</span><span class="p">);</span>

<span class="cm">/* Make a crypto.Verifier with this key */</span>
<span class="kd">var</span> <span class="nx">v</span> <span class="o">=</span> <span class="nx">key</span><span class="p">.</span><span class="nx">createVerify</span><span class="p">(</span><span class="s1">'sha1'</span><span class="p">);</span>
<span class="nx">v</span><span class="p">.</span><span class="nx">update</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">valid</span> <span class="o">=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">verify</span><span class="p">(</span><span class="nx">signature</span><span class="p">);</span>
<span class="cm">/* =&gt; true! */</span>
</code></pre>

<p>Matching fingerprints with keys:</p>
<pre class="highlight javascript"><code><span class="kd">var</span> <span class="nx">fp</span> <span class="o">=</span> <span class="nx">sshpk</span><span class="p">.</span><span class="nx">parseFingerprint</span><span class="p">(</span><span class="s1">'SHA256:PYC9kPVC6J873CSIbfp0LwYeczP/W4ffObNCuDJ1u5w'</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">keys</span> <span class="o">=</span> <span class="p">[</span><span class="nx">sshpk</span><span class="p">.</span><span class="nx">parseKey</span><span class="p">(...),</span> <span class="nx">sshpk</span><span class="p">.</span><span class="nx">parseKey</span><span class="p">(...),</span> <span class="p">...];</span>

<span class="nx">keys</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">fp</span><span class="p">.</span><span class="nx">matches</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'found it!'</span><span class="p">);</span>
<span class="p">});</span>
</code></pre>

<h2 id="usage">Usage</h2>

<h2 id="public-keys">Public keys</h2>

<h3 id="parsekey-data-format-39-auto-39-options"><code class="prettyprint">parseKey(data[, format = &#39;auto&#39;[, options]])</code></h3>

<p>Parses a key from a given data format and returns a new <code class="prettyprint">Key</code> object.</p>

<p>Parameters</p>

<ul>
<li><code class="prettyprint">data</code> &ndash; Either a Buffer or String, containing the key</li>
<li><code class="prettyprint">format</code> &ndash; String name of format to use, valid options are:

<ul>
<li><code class="prettyprint">auto</code>: choose automatically from all below</li>
<li><code class="prettyprint">pem</code>: supports both PKCS#1 and PKCS#8</li>
<li><code class="prettyprint">ssh</code>: standard OpenSSH format,</li>
<li><code class="prettyprint">pkcs1</code>, <code class="prettyprint">pkcs8</code>: variants of <code class="prettyprint">pem</code></li>
<li><code class="prettyprint">rfc4253</code>: raw OpenSSH wire format</li>
<li><code class="prettyprint">openssh</code>: new post-OpenSSH 6.5 internal format, produced by 
       <code class="prettyprint">ssh-keygen -o</code></li>
</ul></li>
<li><code class="prettyprint">options</code> &ndash; Optional Object, extra options, with keys:

<ul>
<li><code class="prettyprint">filename</code> &ndash; Optional String, name for the key being parsed 
          (eg. the filename that was opened). Used to generate
          Error messages</li>
<li><code class="prettyprint">passphrase</code> &ndash; Optional String, encryption passphrase used to decrypt an
            encrypted PEM file</li>
</ul></li>
</ul>

<h3 id="key-iskey-obj"><code class="prettyprint">Key.isKey(obj)</code></h3>

<p>Returns <code class="prettyprint">true</code> if the given object is a valid <code class="prettyprint">Key</code> object created by a version
of <code class="prettyprint">sshpk</code> compatible with this one.</p>

<p>Parameters</p>

<ul>
<li><code class="prettyprint">obj</code> &ndash; Object to identify</li>
</ul>

<h3 id="key-type"><code class="prettyprint">Key#type</code></h3>

<p>String, the type of key. Valid options are <code class="prettyprint">rsa</code>, <code class="prettyprint">dsa</code>, <code class="prettyprint">ecdsa</code>.</p>

<h3 id="key-size"><code class="prettyprint">Key#size</code></h3>

<p>Integer, &ldquo;size&rdquo; of the key in bits. For RSA/DSA this is the size of the modulus;
for ECDSA this is the bit size of the curve in use.</p>

<h3 id="key-comment"><code class="prettyprint">Key#comment</code></h3>

<p>Optional string, a key comment used by some formats (eg the <code class="prettyprint">ssh</code> format).</p>

<h3 id="key-curve"><code class="prettyprint">Key#curve</code></h3>

<p>Only present if <code class="prettyprint">this.type === &#39;ecdsa&#39;</code>, string containing the name of the
named curve used with this key. Possible values include <code class="prettyprint">nistp256</code>, <code class="prettyprint">nistp384</code>
and <code class="prettyprint">nistp521</code>.</p>

<h3 id="key-tobuffer-format-39-ssh-39"><code class="prettyprint">Key#toBuffer([format = &#39;ssh&#39;])</code></h3>

<p>Convert the key into a given data format and return the serialized key as
a Buffer.</p>

<p>Parameters</p>

<ul>
<li><code class="prettyprint">format</code> &ndash; String name of format to use, for valid options see <code class="prettyprint">parseKey()</code></li>
</ul>

<h3 id="key-tostring-format-39-ssh"><code class="prettyprint">Key#toString([format = &#39;ssh])</code></h3>

<p>Same as <code class="prettyprint">this.toBuffer(format).toString()</code>.</p>

<h3 id="key-fingerprint-algorithm-39-sha256-39"><code class="prettyprint">Key#fingerprint([algorithm = &#39;sha256&#39;])</code></h3>

<p>Creates a new <code class="prettyprint">Fingerprint</code> object representing this Key&rsquo;s fingerprint.</p>

<p>Parameters</p>

<ul>
<li><code class="prettyprint">algorithm</code> &ndash; String name of hash algorithm to use, valid options are <code class="prettyprint">md5</code>,
             <code class="prettyprint">sha1</code>, <code class="prettyprint">sha256</code>, <code class="prettyprint">sha384</code>, <code class="prettyprint">sha512</code></li>
</ul>

<h3 id="key-createverify-hashalgorithm"><code class="prettyprint">Key#createVerify([hashAlgorithm])</code></h3>

<p>Creates a <code class="prettyprint">crypto.Verifier</code> specialized to use this Key (and the correct public
key algorithm to match it). The returned Verifier has the same API as a regular
one, except that the <code class="prettyprint">verify()</code> function takes only the target signature as an
argument.</p>

<p>Parameters</p>

<ul>
<li><code class="prettyprint">hashAlgorithm</code> &ndash; optional String name of hash algorithm to use, any
                 supported by OpenSSL are valid, usually including
                 <code class="prettyprint">sha1</code>, <code class="prettyprint">sha256</code>.</li>
</ul>

<p><code class="prettyprint">v.verify(signature[, format])</code> Parameters</p>

<ul>
<li><code class="prettyprint">signature</code> &ndash; either a Signature object, or a Buffer or String</li>
<li><code class="prettyprint">format</code> &ndash; optional String, name of format to interpret given String with.
          Not valid if <code class="prettyprint">signature</code> is a Signature or Buffer.</li>
</ul>

<h3 id="key-creatediffiehellman"><code class="prettyprint">Key#createDiffieHellman()</code></h3>

<h3 id="key-createdh"><code class="prettyprint">Key#createDH()</code></h3>

<p>Creates a Diffie-Hellman key exchange object initialized with this key and all
necessary parameters. This has the same API as a <code class="prettyprint">crypto.DiffieHellman</code>
instance, except that functions take <code class="prettyprint">Key</code> and <code class="prettyprint">PrivateKey</code> objects as
arguments, and return them where indicated for.</p>

<p>This is only valid for keys belonging to a cryptosystem that supports DHE
or a close analogue (i.e. <code class="prettyprint">dsa</code>, <code class="prettyprint">ecdsa</code> and <code class="prettyprint">curve25519</code> keys). An attempt
to call this function on other keys will yield an <code class="prettyprint">Error</code>.</p>

<h2 id="private-keys">Private keys</h2>

<h3 id="parseprivatekey-data-format-39-auto-39-options"><code class="prettyprint">parsePrivateKey(data[, format = &#39;auto&#39;[, options]])</code></h3>

<p>Parses a private key from a given data format and returns a new
<code class="prettyprint">PrivateKey</code> object.</p>

<p>Parameters</p>

<ul>
<li><code class="prettyprint">data</code> &ndash; Either a Buffer or String, containing the key</li>
<li><code class="prettyprint">format</code> &ndash; String name of format to use, valid options are:

<ul>
<li><code class="prettyprint">auto</code>: choose automatically from all below</li>
<li><code class="prettyprint">pem</code>: supports both PKCS#1 and PKCS#8</li>
<li><code class="prettyprint">ssh</code>, <code class="prettyprint">openssh</code>: new post-OpenSSH 6.5 internal format, produced by 
              <code class="prettyprint">ssh-keygen -o</code></li>
<li><code class="prettyprint">pkcs1</code>, <code class="prettyprint">pkcs8</code>: variants of <code class="prettyprint">pem</code></li>
<li><code class="prettyprint">rfc4253</code>: raw OpenSSH wire format</li>
</ul></li>
<li><code class="prettyprint">options</code> &ndash; Optional Object, extra options, with keys:

<ul>
<li><code class="prettyprint">filename</code> &ndash; Optional String, name for the key being parsed 
          (eg. the filename that was opened). Used to generate
          Error messages</li>
<li><code class="prettyprint">passphrase</code> &ndash; Optional String, encryption passphrase used to decrypt an
            encrypted PEM file</li>
</ul></li>
</ul>

<h3 id="privatekey-isprivatekey-obj"><code class="prettyprint">PrivateKey.isPrivateKey(obj)</code></h3>

<p>Returns <code class="prettyprint">true</code> if the given object is a valid <code class="prettyprint">PrivateKey</code> object created by a
version of <code class="prettyprint">sshpk</code> compatible with this one.</p>

<p>Parameters</p>

<ul>
<li><code class="prettyprint">obj</code> &ndash; Object to identify</li>
</ul>

<h3 id="privatekey-type"><code class="prettyprint">PrivateKey#type</code></h3>

<p>String, the type of key. Valid options are <code class="prettyprint">rsa</code>, <code class="prettyprint">dsa</code>, <code class="prettyprint">ecdsa</code>.</p>

<h3 id="privatekey-size"><code class="prettyprint">PrivateKey#size</code></h3>

<p>Integer, &ldquo;size&rdquo; of the key in bits. For RSA/DSA this is the size of the modulus;
for ECDSA this is the bit size of the curve in use.</p>

<h3 id="privatekey-curve"><code class="prettyprint">PrivateKey#curve</code></h3>

<p>Only present if <code class="prettyprint">this.type === &#39;ecdsa&#39;</code>, string containing the name of the
named curve used with this key. Possible values include <code class="prettyprint">nistp256</code>, <code class="prettyprint">nistp384</code>
and <code class="prettyprint">nistp521</code>.</p>

<h3 id="privatekey-tobuffer-format-39-pkcs1-39"><code class="prettyprint">PrivateKey#toBuffer([format = &#39;pkcs1&#39;])</code></h3>

<p>Convert the key into a given data format and return the serialized key as
a Buffer.</p>

<p>Parameters</p>

<ul>
<li><code class="prettyprint">format</code> &ndash; String name of format to use, valid options are listed under 
          <code class="prettyprint">parsePrivateKey</code>. Note that ED25519 keys default to <code class="prettyprint">openssh</code>
          format instead (as they have no <code class="prettyprint">pkcs1</code> representation).</li>
</ul>

<h3 id="privatekey-tostring-format-39-pkcs1-39"><code class="prettyprint">PrivateKey#toString([format = &#39;pkcs1&#39;])</code></h3>

<p>Same as <code class="prettyprint">this.toBuffer(format).toString()</code>.</p>

<h3 id="privatekey-topublic"><code class="prettyprint">PrivateKey#toPublic()</code></h3>

<p>Extract just the public part of this private key, and return it as a <code class="prettyprint">Key</code>
object.</p>

<h3 id="privatekey-fingerprint-algorithm-39-sha256-39"><code class="prettyprint">PrivateKey#fingerprint([algorithm = &#39;sha256&#39;])</code></h3>

<p>Same as <code class="prettyprint">this.toPublic().fingerprint()</code>.</p>

<h3 id="privatekey-createverify-hashalgorithm"><code class="prettyprint">PrivateKey#createVerify([hashAlgorithm])</code></h3>

<p>Same as <code class="prettyprint">this.toPublic().createVerify()</code>.</p>

<h3 id="privatekey-createsign-hashalgorithm"><code class="prettyprint">PrivateKey#createSign([hashAlgorithm])</code></h3>

<p>Creates a <code class="prettyprint">crypto.Sign</code> specialized to use this PrivateKey (and the correct
key algorithm to match it). The returned Signer has the same API as a regular
one, except that the <code class="prettyprint">sign()</code> function takes no arguments, and returns a
<code class="prettyprint">Signature</code> object.</p>

<p>Parameters</p>

<ul>
<li><code class="prettyprint">hashAlgorithm</code> &ndash; optional String name of hash algorithm to use, any
                 supported by OpenSSL are valid, usually including
                 <code class="prettyprint">sha1</code>, <code class="prettyprint">sha256</code>.</li>
</ul>

<p><code class="prettyprint">v.sign()</code> Parameters</p>

<ul>
<li>none</li>
</ul>

<h3 id="privatekey-derive-newtype"><code class="prettyprint">PrivateKey#derive(newType)</code></h3>

<p>Derives a related key of type <code class="prettyprint">newType</code> from this key. Currently this is
only supported to change between <code class="prettyprint">ed25519</code> and <code class="prettyprint">curve25519</code> keys which are
stored with the same private key (but usually distinct public keys in order
to avoid degenerate keys that lead to a weak Diffie-Hellman exchange).</p>

<p>Parameters</p>

<ul>
<li><code class="prettyprint">newType</code> &ndash; String, type of key to derive, either <code class="prettyprint">ed25519</code> or <code class="prettyprint">curve25519</code></li>
</ul>

<h2 id="fingerprints">Fingerprints</h2>

<h3 id="parsefingerprint-fingerprint-algorithms"><code class="prettyprint">parseFingerprint(fingerprint[, algorithms])</code></h3>

<p>Pre-parses a fingerprint, creating a <code class="prettyprint">Fingerprint</code> object that can be used to
quickly locate a key by using the <code class="prettyprint">Fingerprint#matches</code> function.</p>

<p>Parameters</p>

<ul>
<li><code class="prettyprint">fingerprint</code> &ndash; String, the fingerprint value, in any supported format</li>
<li><code class="prettyprint">algorithms</code> &ndash; Optional list of strings, names of hash algorithms to limit
              support to. If <code class="prettyprint">fingerprint</code> uses a hash algorithm not on
              this list, throws <code class="prettyprint">InvalidAlgorithmError</code>.</li>
</ul>

<h3 id="fingerprint-isfingerprint-obj"><code class="prettyprint">Fingerprint.isFingerprint(obj)</code></h3>

<p>Returns <code class="prettyprint">true</code> if the given object is a valid <code class="prettyprint">Fingerprint</code> object created by a
version of <code class="prettyprint">sshpk</code> compatible with this one.</p>

<p>Parameters</p>

<ul>
<li><code class="prettyprint">obj</code> &ndash; Object to identify</li>
</ul>

<h3 id="fingerprint-tostring-format"><code class="prettyprint">Fingerprint#toString([format])</code></h3>

<p>Returns a fingerprint as a string, in the given format.</p>

<p>Parameters</p>

<ul>
<li><code class="prettyprint">format</code> &ndash; Optional String, format to use, valid options are <code class="prettyprint">hex</code> and
          <code class="prettyprint">base64</code>. If this <code class="prettyprint">Fingerprint</code> uses the <code class="prettyprint">md5</code> algorithm, the
          default format is <code class="prettyprint">hex</code>. Otherwise, the default is <code class="prettyprint">base64</code>.</li>
</ul>

<h3 id="fingerprint-matches-key"><code class="prettyprint">Fingerprint#matches(key)</code></h3>

<p>Verifies whether or not this <code class="prettyprint">Fingerprint</code> matches a given <code class="prettyprint">Key</code>. This function
uses double-hashing to avoid leaking timing information. Returns a boolean.</p>

<p>Parameters</p>

<ul>
<li><code class="prettyprint">key</code> &ndash; a <code class="prettyprint">Key</code> object, the key to match this fingerprint against</li>
</ul>

<h2 id="signatures">Signatures</h2>

<h3 id="parsesignature-signature-algorithm-format"><code class="prettyprint">parseSignature(signature, algorithm, format)</code></h3>

<p>Parses a signature in a given format, creating a <code class="prettyprint">Signature</code> object. Useful
for converting between the SSH and ASN.1 (PKCS/OpenSSL) signature formats, and
also returned as output from <code class="prettyprint">PrivateKey#createSign().sign()</code>.</p>

<p>A Signature object can also be passed to a verifier produced by
<code class="prettyprint">Key#createVerify()</code> and it will automatically be converted internally into the
correct format for verification.</p>

<p>Parameters</p>

<ul>
<li><code class="prettyprint">signature</code> &ndash; a Buffer (binary) or String (base64), data of the actual
             signature in the given format</li>
<li><code class="prettyprint">algorithm</code> &ndash; a String, name of the algorithm to be used, possible values
             are <code class="prettyprint">rsa</code>, <code class="prettyprint">dsa</code>, <code class="prettyprint">ecdsa</code></li>
<li><code class="prettyprint">format</code> &ndash; a String, either <code class="prettyprint">asn1</code> or <code class="prettyprint">ssh</code></li>
</ul>

<h3 id="signature-issignature-obj"><code class="prettyprint">Signature.isSignature(obj)</code></h3>

<p>Returns <code class="prettyprint">true</code> if the given object is a valid <code class="prettyprint">Signature</code> object created by a
version of <code class="prettyprint">sshpk</code> compatible with this one.</p>

<p>Parameters</p>

<ul>
<li><code class="prettyprint">obj</code> &ndash; Object to identify</li>
</ul>

<h3 id="signature-tobuffer-format-39-asn1-39"><code class="prettyprint">Signature#toBuffer([format = &#39;asn1&#39;])</code></h3>

<p>Converts a Signature to the given format and returns it as a Buffer.</p>

<p>Parameters</p>

<ul>
<li><code class="prettyprint">format</code> &ndash; a String, either <code class="prettyprint">asn1</code> or <code class="prettyprint">ssh</code></li>
</ul>

<h3 id="signature-tostring-format-39-asn1-39"><code class="prettyprint">Signature#toString([format = &#39;asn1&#39;])</code></h3>

<p>Same as <code class="prettyprint">this.toBuffer(format).toString(&#39;base64&#39;)</code>.</p>

<h2 id="certificates">Certificates</h2>

<p><code class="prettyprint">sshpk</code> includes basic support for parsing certificates in X.509 (PEM) format
and the OpenSSH certificate format. This feature is intended to be used mainly
to access basic metadata about certificates, extract public keys from them, and
also to generate simple self-signed certificates from an existing key.</p>

<p>Notably, there is no implementation of CA chain-of-trust verification, and no
support for key usage restrictions (or other kinds of restrictions). Please do
the security world a favour, and DO NOT use this code for certificate
verification in the traditional X.509 CA chain style.</p>

<h3 id="parsecertificate-data-format"><code class="prettyprint">parseCertificate(data, format)</code></h3>

<p>Parameters</p>

<ul>
<li><code class="prettyprint">data</code> &ndash; a Buffer or String</li>
<li><code class="prettyprint">format</code> &ndash; a String, format to use, one of <code class="prettyprint">&#39;openssh&#39;</code>, <code class="prettyprint">&#39;pem&#39;</code> (X.509 in a
           PEM wrapper), or <code class="prettyprint">&#39;x509&#39;</code> (raw DER encoded)</li>
</ul>

<h3 id="createselfsignedcertificate-subject-privatekey-options"><code class="prettyprint">createSelfSignedCertificate(subject, privateKey[, options])</code></h3>

<p>Parameters</p>

<ul>
<li><code class="prettyprint">subject</code> &ndash; an Identity, the subject of the certificate</li>
<li><code class="prettyprint">privateKey</code> &ndash; a PrivateKey, the key of the subject: will be used both to be
               placed in the certificate and also to sign it (since this is
               a self-signed certificate)</li>
<li><code class="prettyprint">options</code> &ndash; optional Object, with keys:

<ul>
<li><code class="prettyprint">lifetime</code> &ndash; optional Number, lifetime of the certificate from now in
           seconds</li>
<li><code class="prettyprint">validFrom</code>, <code class="prettyprint">validUntil</code> &ndash; optional Dates, beginning and end of
                          certificate validity period. If given
                          <code class="prettyprint">lifetime</code> will be ignored</li>
<li><code class="prettyprint">serial</code> &ndash; optional Buffer, the serial number of the certificate</li>
</ul></li>
</ul>

<h3 id="createcertificate-subject-key-issuer-issuerkey-options"><code class="prettyprint">createCertificate(subject, key, issuer, issuerKey[, options])</code></h3>

<p>Parameters</p>

<ul>
<li><code class="prettyprint">subject</code> &ndash; an Identity, the subject of the certificate</li>
<li><code class="prettyprint">key</code> &ndash; a Key, the public key of the subject</li>
<li><code class="prettyprint">issuer</code> &ndash; an Identity, the issuer of the certificate who will sign it</li>
<li><code class="prettyprint">issuerKey</code> &ndash; a PrivateKey, the issuer&rsquo;s private key for signing</li>
<li><code class="prettyprint">options</code> &ndash; optional Object, with keys:

<ul>
<li><code class="prettyprint">lifetime</code> &ndash; optional Number, lifetime of the certificate from now in
           seconds</li>
<li><code class="prettyprint">validFrom</code>, <code class="prettyprint">validUntil</code> &ndash; optional Dates, beginning and end of
                          certificate validity period. If given
                          <code class="prettyprint">lifetime</code> will be ignored</li>
<li><code class="prettyprint">serial</code> &ndash; optional Buffer, the serial number of the certificate</li>
</ul></li>
</ul>

<h3 id="certificate-subjects"><code class="prettyprint">Certificate#subjects</code></h3>

<p>Array of <code class="prettyprint">Identity</code> instances describing the subject of this certificate.</p>

<h3 id="certificate-issuer"><code class="prettyprint">Certificate#issuer</code></h3>

<p>The <code class="prettyprint">Identity</code> of the Certificate&rsquo;s issuer (signer).</p>

<h3 id="certificate-subjectkey"><code class="prettyprint">Certificate#subjectKey</code></h3>

<p>The public key of the subject of the certificate, as a <code class="prettyprint">Key</code> instance.</p>

<h3 id="certificate-issuerkey"><code class="prettyprint">Certificate#issuerKey</code></h3>

<p>The public key of the signing issuer of this certificate, as a <code class="prettyprint">Key</code> instance.
May be <code class="prettyprint">undefined</code> if the issuer&rsquo;s key is unknown (e.g. on an X509 certificate).</p>

<h3 id="certificate-serial"><code class="prettyprint">Certificate#serial</code></h3>

<p>The serial number of the certificate. As this is normally a 64-bit or wider
integer, it is returned as a Buffer.</p>

<h3 id="certificate-isexpired-when"><code class="prettyprint">Certificate#isExpired([when])</code></h3>

<p>Tests whether the Certificate is currently expired (i.e. the <code class="prettyprint">validFrom</code> and
<code class="prettyprint">validUntil</code> dates specify a range of time that does not include the current
time).</p>

<p>Parameters</p>

<ul>
<li><code class="prettyprint">when</code> &ndash; optional Date, if specified, tests whether the Certificate was or
         will be expired at the specified time instead of now</li>
</ul>

<p>Returns a Boolean.</p>

<h3 id="certificate-issignedbykey-key"><code class="prettyprint">Certificate#isSignedByKey(key)</code></h3>

<p>Tests whether the Certificate was validly signed by the given (public) Key.</p>

<p>Parameters</p>

<ul>
<li><code class="prettyprint">key</code> &ndash; a Key instance</li>
</ul>

<p>Returns a Boolean.</p>

<h3 id="certificate-issignedby-certificate"><code class="prettyprint">Certificate#isSignedBy(certificate)</code></h3>

<p>Tests whether this Certificate was validly signed by the subject of the given
certificate. Also tests that the issuer Identity of this Certificate and the
subject Identity of the other Certificate are equivalent.</p>

<p>Parameters</p>

<ul>
<li><code class="prettyprint">certificate</code> &ndash; another Certificate instance</li>
</ul>

<p>Returns a Boolean.</p>

<h3 id="certificate-fingerprint-hashalgo"><code class="prettyprint">Certificate#fingerprint([hashAlgo])</code></h3>

<p>Returns the X509-style fingerprint of the entire certificate (as a Fingerprint
instance). This matches what a web-browser or similar would display as the
certificate fingerprint and should not be confused with the fingerprint of the
subject&rsquo;s public key.</p>

<p>Parameters</p>

<ul>
<li><code class="prettyprint">hashAlgo</code> &ndash; an optional String, any hash function name</li>
</ul>

<h3 id="certificate-tobuffer-format"><code class="prettyprint">Certificate#toBuffer([format])</code></h3>

<p>Serializes the Certificate to a Buffer and returns it.</p>

<p>Parameters</p>

<ul>
<li><code class="prettyprint">format</code> &ndash; an optional String, output format, one of <code class="prettyprint">&#39;openssh&#39;</code>, <code class="prettyprint">&#39;pem&#39;</code> or
           <code class="prettyprint">&#39;x509&#39;</code>. Defaults to <code class="prettyprint">&#39;x509&#39;</code>.</li>
</ul>

<p>Returns a Buffer.</p>

<h3 id="certificate-tostring-format"><code class="prettyprint">Certificate#toString([format])</code></h3>

<ul>
<li><code class="prettyprint">format</code> &ndash; an optional String, output format, one of <code class="prettyprint">&#39;openssh&#39;</code>, <code class="prettyprint">&#39;pem&#39;</code> or
           <code class="prettyprint">&#39;x509&#39;</code>. Defaults to <code class="prettyprint">&#39;pem&#39;</code>.</li>
</ul>

<p>Returns a String.</p>

<h2 id="certificate-identities">Certificate identities</h2>

<h3 id="identityforhost-hostname"><code class="prettyprint">identityForHost(hostname)</code></h3>

<p>Constructs a host-type Identity for a given hostname.</p>

<p>Parameters</p>

<ul>
<li><code class="prettyprint">hostname</code> &ndash; the fully qualified DNS name of the host</li>
</ul>

<p>Returns an Identity instance.</p>

<h3 id="identityforuser-uid"><code class="prettyprint">identityForUser(uid)</code></h3>

<p>Constructs a user-type Identity for a given UID.</p>

<p>Parameters</p>

<ul>
<li><code class="prettyprint">uid</code> &ndash; a String, user identifier (login name)</li>
</ul>

<p>Returns an Identity instance.</p>

<h3 id="identityforemail-email"><code class="prettyprint">identityForEmail(email)</code></h3>

<p>Constructs an email-type Identity for a given email address.</p>

<p>Parameters</p>

<ul>
<li><code class="prettyprint">email</code> &ndash; a String, email address</li>
</ul>

<p>Returns an Identity instance.</p>

<h3 id="identityfromdn-dn"><code class="prettyprint">identityFromDN(dn)</code></h3>

<p>Parses an LDAP-style DN string (e.g. <code class="prettyprint">&#39;CN=foo, C=US&#39;</code>) and turns it into an
Identity instance.</p>

<p>Parameters</p>

<ul>
<li><code class="prettyprint">dn</code> &ndash; a String</li>
</ul>

<p>Returns an Identity instance.</p>

<h3 id="identity-tostring"><code class="prettyprint">Identity#toString()</code></h3>

<p>Returns the identity as an LDAP-style DN string.
e.g. <code class="prettyprint">&#39;CN=foo, O=bar corp, C=us&#39;</code></p>

<h3 id="identity-type"><code class="prettyprint">Identity#type</code></h3>

<p>The type of identity. One of <code class="prettyprint">&#39;host&#39;</code>, <code class="prettyprint">&#39;user&#39;</code>, <code class="prettyprint">&#39;email&#39;</code> or <code class="prettyprint">&#39;unknown&#39;</code></p>

<h3 id="identity-hostname"><code class="prettyprint">Identity#hostname</code></h3>

<h3 id="identity-uid"><code class="prettyprint">Identity#uid</code></h3>

<h3 id="identity-email"><code class="prettyprint">Identity#email</code></h3>

<p>Set when <code class="prettyprint">type</code> is <code class="prettyprint">&#39;host&#39;</code>, <code class="prettyprint">&#39;user&#39;</code>, or <code class="prettyprint">&#39;email&#39;</code>, respectively. Strings.</p>

<h3 id="identity-cn"><code class="prettyprint">Identity#cn</code></h3>

<p>The value of the first <code class="prettyprint">CN=</code> in the DN, if any.</p>

<h2 id="errors">Errors</h2>

<h3 id="invalidalgorithmerror"><code class="prettyprint">InvalidAlgorithmError</code></h3>

<p>The specified algorithm is not valid, either because it is not supported, or
because it was not included on a list of allowed algorithms.</p>

<p>Thrown by <code class="prettyprint">Fingerprint.parse</code>, <code class="prettyprint">Key#fingerprint</code>.</p>

<p>Properties</p>

<ul>
<li><code class="prettyprint">algorithm</code> &ndash; the algorithm that could not be validated</li>
</ul>

<h3 id="fingerprintformaterror"><code class="prettyprint">FingerprintFormatError</code></h3>

<p>The fingerprint string given could not be parsed as a supported fingerprint
format, or the specified fingerprint format is invalid.</p>

<p>Thrown by <code class="prettyprint">Fingerprint.parse</code>, <code class="prettyprint">Fingerprint#toString</code>.</p>

<p>Properties</p>

<ul>
<li><code class="prettyprint">fingerprint</code> &ndash; if caused by a fingerprint, the string value given</li>
<li><code class="prettyprint">format</code> &ndash; if caused by an invalid format specification, the string value given</li>
</ul>

<h3 id="keyparseerror"><code class="prettyprint">KeyParseError</code></h3>

<p>The key data given could not be parsed as a valid key.</p>

<p>Properties</p>

<ul>
<li><code class="prettyprint">keyName</code> &ndash; <code class="prettyprint">filename</code> that was given to <code class="prettyprint">parseKey</code></li>
<li><code class="prettyprint">format</code> &ndash; the <code class="prettyprint">format</code> that was trying to parse the key (see <code class="prettyprint">parseKey</code>)</li>
<li><code class="prettyprint">innerErr</code> &ndash; the inner Error thrown by the format parser</li>
</ul>

<h3 id="keyencryptederror"><code class="prettyprint">KeyEncryptedError</code></h3>

<p>The key is encrypted with a symmetric key (ie, it is password protected). The
parsing operation would succeed if it was given the <code class="prettyprint">passphrase</code> option.</p>

<p>Properties</p>

<ul>
<li><code class="prettyprint">keyName</code> &ndash; <code class="prettyprint">filename</code> that was given to <code class="prettyprint">parseKey</code></li>
<li><code class="prettyprint">format</code> &ndash; the <code class="prettyprint">format</code> that was trying to parse the key (currently can only
          be <code class="prettyprint">&quot;pem&quot;</code>)</li>
</ul>

<h3 id="certificateparseerror"><code class="prettyprint">CertificateParseError</code></h3>

<p>The certificate data given could not be parsed as a valid certificate.</p>

<p>Properties</p>

<ul>
<li><code class="prettyprint">certName</code> &ndash; <code class="prettyprint">filename</code> that was given to <code class="prettyprint">parseCertificate</code></li>
<li><code class="prettyprint">format</code> &ndash; the <code class="prettyprint">format</code> that was trying to parse the key
          (see <code class="prettyprint">parseCertificate</code>)</li>
<li><code class="prettyprint">innerErr</code> &ndash; the inner Error thrown by the format parser</li>
</ul>

<h2 id="friends-of-sshpk">Friends of sshpk</h2>

<ul>
<li><a href="https://github.com/arekinath/node-sshpk-agent"><code class="prettyprint">sshpk-agent</code></a> is a library
for speaking the <code class="prettyprint">ssh-agent</code> protocol from node.js, which uses <code class="prettyprint">sshpk</code></li>
</ul>
