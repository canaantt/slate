<h1 id="stream">Stream</h1>

<p>Stability: 2 - Stable</p>

<p>A stream is an abstract interface implemented by various objects in
Node.js. For example a <a href="https://nodejs.org/docs/v5.8.0/api/http.html#http_class_http_incomingmessage">request to an HTTP server</a> is a
stream, as is <a href="https://nodejs.org/docs/v5.8.0/api/process.html#process_process_stdout"><code class="prettyprint">process.stdout</code></a>. Streams are readable, writable, or both. All
streams are instances of <a href="https://nodejs.org/docs/v5.8.0/api/events.html#events_class_eventemitter"><code class="prettyprint">EventEmitter</code></a>.</p>

<p>You can load the Stream base classes by doing <code class="prettyprint">require(&#39;stream&#39;)</code>.
There are base classes provided for <a href="#stream_class_stream_readable">Readable</a> streams, <a href="#stream_class_stream_writable">Writable</a>
streams, <a href="#stream_class_stream_duplex">Duplex</a> streams, and <a href="#stream_class_stream_transform">Transform</a> streams.</p>

<p>This document is split up into 3 sections:</p>

<ol>
<li>The first section explains the parts of the API that you need to be
aware of to use streams in your programs.</li>
<li>The second section explains the parts of the API that you need to
use if you implement your own custom streams yourself. The API is designed to
make this easy for you to do.</li>
<li>The third section goes into more depth about how streams work,
including some of the internal mechanisms and functions that you
should probably not modify unless you definitely know what you are
doing.</li>
</ol>

<h2 id="api-for-stream-consumers">API for Stream Consumers</h2>

<!--type=misc-->

<p>Streams can be either <a href="#stream_class_stream_readable">Readable</a>, <a href="#stream_class_stream_writable">Writable</a>, or both (<a href="#stream_class_stream_duplex">Duplex</a>).</p>

<p>All streams are EventEmitters, but they also have other custom methods
and properties depending on whether they are Readable, Writable, or
Duplex.</p>

<p>If a stream is both Readable and Writable, then it implements all of
the methods and events. So, a <a href="#stream_class_stream_duplex">Duplex</a> or <a href="#stream_class_stream_transform">Transform</a> stream is
fully described by this API, though their implementation may be
somewhat different.</p>

<p>It is not necessary to implement Stream interfaces in order to consume
streams in your programs. If you <strong>are</strong> implementing streaming
interfaces in your own program, please also refer to
<a href="#stream_api_for_stream_implementors">API for Stream Implementors</a>.</p>

<p>Almost all Node.js programs, no matter how simple, use Streams in some
way. Here is an example of using Streams in an Node.js program:</p>
<pre class="highlight javascript"><code><span class="kr">const</span> <span class="nx">http</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'http'</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">server</span> <span class="o">=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">createServer</span><span class="p">(</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// req is an http.IncomingMessage, which is a Readable Stream</span>
  <span class="c1">// res is an http.ServerResponse, which is a Writable Stream</span>

  <span class="kd">var</span> <span class="nx">body</span> <span class="o">=</span> <span class="s1">''</span><span class="p">;</span>
  <span class="c1">// we want to get the data as utf8 strings</span>
  <span class="c1">// If you don't set an encoding, then you'll get Buffer objects</span>
  <span class="nx">req</span><span class="p">.</span><span class="nx">setEncoding</span><span class="p">(</span><span class="s1">'utf8'</span><span class="p">);</span>

  <span class="c1">// Readable streams emit 'data' events once a listener is added</span>
  <span class="nx">req</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'data'</span><span class="p">,</span> <span class="p">(</span><span class="nx">chunk</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">body</span> <span class="o">+=</span> <span class="nx">chunk</span><span class="p">;</span>
  <span class="p">});</span>

  <span class="c1">// the end event tells you that you have entire body</span>
  <span class="nx">req</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'end'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">body</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">er</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// uh oh!  bad json!</span>
      <span class="nx">res</span><span class="p">.</span><span class="nx">statusCode</span> <span class="o">=</span> <span class="mi">400</span><span class="p">;</span>
      <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="err">`</span><span class="na">error</span><span class="p">:</span> <span class="nx">$</span><span class="p">{</span><span class="nx">er</span><span class="p">.</span><span class="nx">message</span><span class="p">}</span><span class="err">`</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// write back something interesting to the user:</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">data</span><span class="p">);</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">end</span><span class="p">();</span>
  <span class="p">});</span>
<span class="p">});</span>

<span class="nx">server</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="mi">1337</span><span class="p">);</span>

<span class="c1">// $ curl localhost:1337 -d '{}'</span>
<span class="c1">// object</span>
<span class="c1">// $ curl localhost:1337 -d '"foo"'</span>
<span class="c1">// string</span>
<span class="c1">// $ curl localhost:1337 -d 'not json'</span>
<span class="c1">// error: Unexpected token o</span>
</code></pre>

<h3 id="class-stream-duplex">Class: stream.Duplex</h3>

<p>Duplex streams are streams that implement both the <a href="#stream_class_stream_readable">Readable</a> and
<a href="#stream_class_stream_writable">Writable</a> interfaces.</p>

<p>Examples of Duplex streams include:</p>

<ul>
<li><a href="https://nodejs.org/docs/v5.8.0/api/net.html#net_class_net_socket">TCP sockets</a></li>
<li><a href="zlib.html">zlib streams</a></li>
<li><a href="crypto.html">crypto streams</a></li>
</ul>

<h3 id="class-stream-readable">Class: stream.Readable</h3>

<!--type=class-->

<p>The Readable stream interface is the abstraction for a <em>source</em> of
data that you are reading from. In other words, data comes <em>out</em> of a
Readable stream.</p>

<p>A Readable stream will not start emitting data until you indicate that
you are ready to receive it.</p>

<p>Readable streams have two &ldquo;modes&rdquo;: a <strong>flowing mode</strong> and a <strong>paused
mode</strong>. When in flowing mode, data is read from the underlying system
and provided to your program as fast as possible. In paused mode, you
must explicitly call <a href="#stream_readable_read_size"><code class="prettyprint">stream.read()</code></a> to get chunks of data out.
Streams start out in paused mode.</p>

<p><strong>Note</strong>: If no data event handlers are attached, and there are no
<a href="#stream_readable_pipe_destination_options"><code class="prettyprint">stream.pipe()</code></a> destinations, and the stream is switched into flowing
mode, then data will be lost.</p>

<p>You can switch to flowing mode by doing any of the following:</p>

<ul>
<li>Adding a <a href="#stream_event_data"><code class="prettyprint">&#39;data&#39;</code></a> event handler to listen for data.</li>
<li>Calling the <a href="#stream_readable_resume"><code class="prettyprint">stream.resume()</code></a> method to explicitly open the
flow.</li>
<li>Calling the <a href="#stream_readable_pipe_destination_options"><code class="prettyprint">stream.pipe()</code></a> method to send the data to a <a href="#stream_class_stream_writable">Writable</a>.</li>
</ul>

<p>You can switch back to paused mode by doing either of the following:</p>

<ul>
<li>If there are no pipe destinations, by calling the
<a href="#stream_readable_pause"><code class="prettyprint">stream.pause()</code></a> method.</li>
<li>If there are pipe destinations, by removing any <a href="#stream_event_data"><code class="prettyprint">&#39;data&#39;</code></a> event
handlers, and removing all pipe destinations by calling the
<a href="#stream_readable_unpipe_destination"><code class="prettyprint">stream.unpipe()</code></a> method.</li>
</ul>

<p>Note that, for backwards compatibility reasons, removing <a href="#stream_event_data"><code class="prettyprint">&#39;data&#39;</code></a>
event handlers will <strong>not</strong> automatically pause the stream. Also, if
there are piped destinations, then calling <a href="#stream_readable_pause"><code class="prettyprint">stream.pause()</code></a> will
not guarantee that the stream will <em>remain</em> paused once those
destinations drain and ask for more data.</p>

<p>Examples of readable streams include:</p>

<ul>
<li><a href="https://nodejs.org/docs/v5.8.0/api/http.html#http_class_http_incomingmessage">HTTP responses, on the client</a></li>
<li><a href="https://nodejs.org/docs/v5.8.0/api/http.html#http_class_http_incomingmessage">HTTP requests, on the server</a></li>
<li><a href="https://nodejs.org/docs/v5.8.0/api/fs.html#fs_class_fs_readstream">fs read streams</a></li>
<li><a href="zlib.html">zlib streams</a></li>
<li><a href="crypto.html">crypto streams</a></li>
<li><a href="https://nodejs.org/docs/v5.8.0/api/net.html#net_class_net_socket">TCP sockets</a></li>
<li><a href="https://nodejs.org/docs/v5.8.0/api/child_process.html#child_process_child_stdout">child process stdout and stderr</a></li>
<li><a href="https://nodejs.org/docs/v5.8.0/api/process.html#process_process_stdin"><code class="prettyprint">process.stdin</code></a></li>
</ul>

<h4 id="event-39-close-39">Event: &lsquo;close&rsquo;</h4>

<p>Emitted when the stream and any of its underlying resources (a file
descriptor, for example) have been closed. The event indicates that
no more events will be emitted, and no further computation will occur.</p>

<p>Not all streams will emit the <code class="prettyprint">&#39;close&#39;</code> event.</p>

<h4 id="event-39-data-39">Event: &#39;data&rsquo;</h4>

<ul>
<li><code class="prettyprint">chunk</code> {Buffer|String} The chunk of data.</li>
</ul>

<p>Attaching a <code class="prettyprint">&#39;data&#39;</code> event listener to a stream that has not been
explicitly paused will switch the stream into flowing mode. Data will
then be passed as soon as it is available.</p>

<p>If you just want to get all the data out of the stream as fast as
possible, this is the best way to do so.</p>
<pre class="highlight javascript"><code><span class="kd">var</span> <span class="nx">readable</span> <span class="o">=</span> <span class="nx">getReadableStreamSomehow</span><span class="p">();</span>
<span class="nx">readable</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'data'</span><span class="p">,</span> <span class="p">(</span><span class="nx">chunk</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'got %d bytes of data'</span><span class="p">,</span> <span class="nx">chunk</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
<span class="p">});</span>
</code></pre>

<h4 id="event-39-end-39">Event: &#39;end&rsquo;</h4>

<p>This event fires when there will be no more data to read.</p>

<p>Note that the <code class="prettyprint">&#39;end&#39;</code> event <strong>will not fire</strong> unless the data is
completely consumed. This can be done by switching into flowing mode,
or by calling <a href="#stream_readable_read_size"><code class="prettyprint">stream.read()</code></a> repeatedly until you get to the
end.</p>
<pre class="highlight javascript"><code><span class="kd">var</span> <span class="nx">readable</span> <span class="o">=</span> <span class="nx">getReadableStreamSomehow</span><span class="p">();</span>
<span class="nx">readable</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'data'</span><span class="p">,</span> <span class="p">(</span><span class="nx">chunk</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'got %d bytes of data'</span><span class="p">,</span> <span class="nx">chunk</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">readable</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'end'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'there will be no more data.'</span><span class="p">);</span>
<span class="p">});</span>
</code></pre>

<h4 id="event-39-error-39">Event: &#39;error&rsquo;</h4>

<ul>
<li>{Error Object}</li>
</ul>

<p>Emitted if there was an error receiving data.</p>

<h4 id="event-39-readable-39">Event: &#39;readable&rsquo;</h4>

<p>When a chunk of data can be read from the stream, it will emit a
<code class="prettyprint">&#39;readable&#39;</code> event.</p>

<p>In some cases, listening for a <code class="prettyprint">&#39;readable&#39;</code> event will cause some data
to be read into the internal buffer from the underlying system, if it
hadn&rsquo;t already.</p>
<pre class="highlight javascript"><code><span class="kd">var</span> <span class="nx">readable</span> <span class="o">=</span> <span class="nx">getReadableStreamSomehow</span><span class="p">();</span>
<span class="nx">readable</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'readable'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// there is some data to read now</span>
<span class="p">});</span>
</code></pre>

<p>Once the internal buffer is drained, a <code class="prettyprint">&#39;readable&#39;</code> event will fire
again when more data is available.</p>

<p>The <code class="prettyprint">&#39;readable&#39;</code> event is not emitted in the &ldquo;flowing&rdquo; mode with the
sole exception of the last one, on end-of-stream.</p>

<p>The <code class="prettyprint">&#39;readable&#39;</code> event indicates that the stream has new information:
either new data is available or the end of the stream has been reached.
In the former case, <a href="#stream_readable_read_size"><code class="prettyprint">stream.read()</code></a> will return that data. In the
latter case, <a href="#stream_readable_read_size"><code class="prettyprint">stream.read()</code></a> will return null. For instance, in
the following example, <code class="prettyprint">foo.txt</code> is an empty file:</p>
<pre class="highlight javascript"><code><span class="kr">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'fs'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">rr</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">createReadStream</span><span class="p">(</span><span class="s1">'foo.txt'</span><span class="p">);</span>
<span class="nx">rr</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'readable'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'readable:'</span><span class="p">,</span> <span class="nx">rr</span><span class="p">.</span><span class="nx">read</span><span class="p">());</span>
<span class="p">});</span>
<span class="nx">rr</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'end'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'end'</span><span class="p">);</span>
<span class="p">});</span>
</code></pre>

<p>The output of running this script is:</p>
<pre class="highlight plaintext"><code>$ node test.js
readable: null
end
</code></pre>

<h4 id="readable-ispaused">readable.isPaused()</h4>

<ul>
<li>Return: {Boolean}</li>
</ul>

<p>This method returns whether or not the <code class="prettyprint">readable</code> has been <strong>explicitly</strong>
paused by client code (using <a href="#stream_readable_pause"><code class="prettyprint">stream.pause()</code></a> without a
corresponding <a href="#stream_readable_resume"><code class="prettyprint">stream.resume()</code></a>).</p>
<pre class="highlight javascript"><code><span class="kd">var</span> <span class="nx">readable</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">stream</span><span class="p">.</span><span class="nx">Readable</span>

<span class="nx">readable</span><span class="p">.</span><span class="nx">isPaused</span><span class="p">()</span> <span class="c1">// === false</span>
<span class="nx">readable</span><span class="p">.</span><span class="nx">pause</span><span class="p">()</span>
<span class="nx">readable</span><span class="p">.</span><span class="nx">isPaused</span><span class="p">()</span> <span class="c1">// === true</span>
<span class="nx">readable</span><span class="p">.</span><span class="nx">resume</span><span class="p">()</span>
<span class="nx">readable</span><span class="p">.</span><span class="nx">isPaused</span><span class="p">()</span> <span class="c1">// === false</span>
</code></pre>

<h4 id="readable-pause">readable.pause()</h4>

<ul>
<li>Return: <code class="prettyprint">this</code></li>
</ul>

<p>This method will cause a stream in flowing mode to stop emitting
<a href="#stream_event_data"><code class="prettyprint">&#39;data&#39;</code></a> events, switching out of flowing mode. Any data that becomes
available will remain in the internal buffer.</p>
<pre class="highlight javascript"><code><span class="kd">var</span> <span class="nx">readable</span> <span class="o">=</span> <span class="nx">getReadableStreamSomehow</span><span class="p">();</span>
<span class="nx">readable</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'data'</span><span class="p">,</span> <span class="p">(</span><span class="nx">chunk</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'got %d bytes of data'</span><span class="p">,</span> <span class="nx">chunk</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
  <span class="nx">readable</span><span class="p">.</span><span class="nx">pause</span><span class="p">();</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'there will be no more data for 1 second'</span><span class="p">);</span>
  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'now data will start flowing again'</span><span class="p">);</span>
    <span class="nx">readable</span><span class="p">.</span><span class="nx">resume</span><span class="p">();</span>
  <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">});</span>
</code></pre>

<h4 id="readable-pipe-destination-options">readable.pipe(destination[, options])</h4>

<ul>
<li><code class="prettyprint">destination</code> {stream.Writable} The destination for writing data</li>
<li><code class="prettyprint">options</code> {Object} Pipe options

<ul>
<li><code class="prettyprint">end</code> {Boolean} End the writer when the reader ends. Default = <code class="prettyprint">true</code></li>
</ul></li>
</ul>

<p>This method pulls all the data out of a readable stream, and writes it
to the supplied destination, automatically managing the flow so that
the destination is not overwhelmed by a fast readable stream.</p>

<p>Multiple destinations can be piped to safely.</p>
<pre class="highlight javascript"><code><span class="kd">var</span> <span class="nx">readable</span> <span class="o">=</span> <span class="nx">getReadableStreamSomehow</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">writable</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">createWriteStream</span><span class="p">(</span><span class="s1">'file.txt'</span><span class="p">);</span>
<span class="c1">// All the data from readable goes into 'file.txt'</span>
<span class="nx">readable</span><span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">writable</span><span class="p">);</span>
</code></pre>

<p>This function returns the destination stream, so you can set up pipe
chains like so:</p>
<pre class="highlight javascript"><code><span class="kd">var</span> <span class="nx">r</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">createReadStream</span><span class="p">(</span><span class="s1">'file.txt'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">z</span> <span class="o">=</span> <span class="nx">zlib</span><span class="p">.</span><span class="nx">createGzip</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">w</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">createWriteStream</span><span class="p">(</span><span class="s1">'file.txt.gz'</span><span class="p">);</span>
<span class="nx">r</span><span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">z</span><span class="p">).</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">w</span><span class="p">);</span>
</code></pre>

<p>For example, emulating the Unix <code class="prettyprint">cat</code> command:</p>
<pre class="highlight javascript"><code><span class="nx">process</span><span class="p">.</span><span class="nx">stdin</span><span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">stdout</span><span class="p">);</span>
</code></pre>

<p>By default <a href="#stream_writable_end_chunk_encoding_callback"><code class="prettyprint">stream.end()</code></a> is called on the destination when the
source stream emits <a href="#stream_event_end"><code class="prettyprint">&#39;end&#39;</code></a>, so that <code class="prettyprint">destination</code> is no longer writable.
Pass <code class="prettyprint">{ end: false }</code> as <code class="prettyprint">options</code> to keep the destination stream open.</p>

<p>This keeps <code class="prettyprint">writer</code> open so that &ldquo;Goodbye&rdquo; can be written at the
end.</p>
<pre class="highlight javascript"><code><span class="nx">reader</span><span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">writer</span><span class="p">,</span> <span class="p">{</span> <span class="na">end</span><span class="p">:</span> <span class="kc">false</span> <span class="p">});</span>
<span class="nx">reader</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'end'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">writer</span><span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="s1">'Goodbye\n'</span><span class="p">);</span>
<span class="p">});</span>
</code></pre>

<p>Note that <a href="https://nodejs.org/docs/v5.8.0/api/process.html#process_process_stderr"><code class="prettyprint">process.stderr</code></a> and <a href="https://nodejs.org/docs/v5.8.0/api/process.html#process_process_stdout"><code class="prettyprint">process.stdout</code></a> are never closed until
the process exits, regardless of the specified options.</p>

<h4 id="readable-read-size">readable.read([size])</h4>

<ul>
<li><code class="prettyprint">size</code> {Number} Optional argument to specify how much data to read.</li>
<li>Return {String|Buffer|Null}</li>
</ul>

<p>The <code class="prettyprint">read()</code> method pulls some data out of the internal buffer and
returns it. If there is no data available, then it will return
<code class="prettyprint">null</code>.</p>

<p>If you pass in a <code class="prettyprint">size</code> argument, then it will return that many
bytes. If <code class="prettyprint">size</code> bytes are not available, then it will return <code class="prettyprint">null</code>,
unless we&rsquo;ve ended, in which case it will return the data remaining
in the buffer.</p>

<p>If you do not specify a <code class="prettyprint">size</code> argument, then it will return all the
data in the internal buffer.</p>

<p>This method should only be called in paused mode. In flowing mode,
this method is called automatically until the internal buffer is
drained.</p>
<pre class="highlight javascript"><code><span class="kd">var</span> <span class="nx">readable</span> <span class="o">=</span> <span class="nx">getReadableStreamSomehow</span><span class="p">();</span>
<span class="nx">readable</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'readable'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">chunk</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="kc">null</span> <span class="o">!==</span> <span class="p">(</span><span class="nx">chunk</span> <span class="o">=</span> <span class="nx">readable</span><span class="p">.</span><span class="nx">read</span><span class="p">()))</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'got %d bytes of data'</span><span class="p">,</span> <span class="nx">chunk</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre>

<p>If this method returns a data chunk, then it will also trigger the
emission of a <a href="#stream_event_data"><code class="prettyprint">&#39;data&#39;</code></a> event.</p>

<p>Note that calling <a href="#stream_readable_read_size"><code class="prettyprint">stream.read([size])</code></a> after the <a href="#stream_event_end"><code class="prettyprint">&#39;end&#39;</code></a>
event has been triggered will return <code class="prettyprint">null</code>. No runtime error will be raised.</p>

<h4 id="readable-resume">readable.resume()</h4>

<ul>
<li>Return: <code class="prettyprint">this</code></li>
</ul>

<p>This method will cause the readable stream to resume emitting <a href="#stream_event_data"><code class="prettyprint">&#39;data&#39;</code></a>
events.</p>

<p>This method will switch the stream into flowing mode. If you do <em>not</em>
want to consume the data from a stream, but you <em>do</em> want to get to
its <a href="#stream_event_end"><code class="prettyprint">&#39;end&#39;</code></a> event, you can call <a href="#stream_readable_resume"><code class="prettyprint">stream.resume()</code></a> to open
the flow of data.</p>
<pre class="highlight javascript"><code><span class="kd">var</span> <span class="nx">readable</span> <span class="o">=</span> <span class="nx">getReadableStreamSomehow</span><span class="p">();</span>
<span class="nx">readable</span><span class="p">.</span><span class="nx">resume</span><span class="p">();</span>
<span class="nx">readable</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'end'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'got to the end, but did not read anything'</span><span class="p">);</span>
<span class="p">});</span>
</code></pre>

<h4 id="readable-setencoding-encoding">readable.setEncoding(encoding)</h4>

<ul>
<li><code class="prettyprint">encoding</code> {String} The encoding to use.</li>
<li>Return: <code class="prettyprint">this</code></li>
</ul>

<p>Call this function to cause the stream to return strings of the specified
encoding instead of Buffer objects. For example, if you do
<code class="prettyprint">readable.setEncoding(&#39;utf8&#39;)</code>, then the output data will be interpreted as
UTF-8 data, and returned as strings. If you do <code class="prettyprint">readable.setEncoding(&#39;hex&#39;)</code>,
then the data will be encoded in hexadecimal string format.</p>

<p>This properly handles multi-byte characters that would otherwise be
potentially mangled if you simply pulled the Buffers directly and
called <a href="https://nodejs.org/docs/v5.8.0/api/buffer.html#buffer_buf_tostring_encoding_start_end"><code class="prettyprint">buf.toString(encoding)</code></a> on them. If you want to read the data
as strings, always use this method.</p>

<p>Also you can disable any encoding at all with <code class="prettyprint">readable.setEncoding(null)</code>.
This approach is very useful if you deal with binary data or with large
multi-byte strings spread out over multiple chunks.</p>
<pre class="highlight javascript"><code><span class="kd">var</span> <span class="nx">readable</span> <span class="o">=</span> <span class="nx">getReadableStreamSomehow</span><span class="p">();</span>
<span class="nx">readable</span><span class="p">.</span><span class="nx">setEncoding</span><span class="p">(</span><span class="s1">'utf8'</span><span class="p">);</span>
<span class="nx">readable</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'data'</span><span class="p">,</span> <span class="p">(</span><span class="nx">chunk</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">assert</span><span class="p">.</span><span class="nx">equal</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">chunk</span><span class="p">,</span> <span class="s1">'string'</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'got %d characters of string data'</span><span class="p">,</span> <span class="nx">chunk</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
<span class="p">});</span>
</code></pre>

<h4 id="readable-unpipe-destination">readable.unpipe([destination])</h4>

<ul>
<li><code class="prettyprint">destination</code> {stream.Writable} Optional specific stream to unpipe</li>
</ul>

<p>This method will remove the hooks set up for a previous <a href="#stream_readable_pipe_destination_options"><code class="prettyprint">stream.pipe()</code></a>
call.</p>

<p>If the destination is not specified, then all pipes are removed.</p>

<p>If the destination is specified, but no pipe is set up for it, then
this is a no-op.</p>
<pre class="highlight javascript"><code><span class="kd">var</span> <span class="nx">readable</span> <span class="o">=</span> <span class="nx">getReadableStreamSomehow</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">writable</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">createWriteStream</span><span class="p">(</span><span class="s1">'file.txt'</span><span class="p">);</span>
<span class="c1">// All the data from readable goes into 'file.txt',</span>
<span class="c1">// but only for the first second</span>
<span class="nx">readable</span><span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">writable</span><span class="p">);</span>
<span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'stop writing to file.txt'</span><span class="p">);</span>
  <span class="nx">readable</span><span class="p">.</span><span class="nx">unpipe</span><span class="p">(</span><span class="nx">writable</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'manually close the file stream'</span><span class="p">);</span>
  <span class="nx">writable</span><span class="p">.</span><span class="nx">end</span><span class="p">();</span>
<span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
</code></pre>

<h4 id="readable-unshift-chunk">readable.unshift(chunk)</h4>

<ul>
<li><code class="prettyprint">chunk</code> {Buffer|String} Chunk of data to unshift onto the read queue</li>
</ul>

<p>This is useful in certain cases where a stream is being consumed by a
parser, which needs to &ldquo;un-consume&rdquo; some data that it has
optimistically pulled out of the source, so that the stream can be
passed on to some other party.</p>

<p>Note that <code class="prettyprint">stream.unshift(chunk)</code> cannot be called after the <a href="#stream_event_end"><code class="prettyprint">&#39;end&#39;</code></a> event
has been triggered; a runtime error will be raised.</p>

<p>If you find that you must often call <code class="prettyprint">stream.unshift(chunk)</code> in your
programs, consider implementing a <a href="#stream_class_stream_transform">Transform</a> stream instead. (See <a href="#stream_api_for_stream_implementors">API
for Stream Implementors</a>.)</p>
<pre class="highlight javascript"><code><span class="c1">// Pull off a header delimited by \n\n</span>
<span class="c1">// use unshift() if we get too much</span>
<span class="c1">// Call the callback with (error, header, stream)</span>
<span class="kr">const</span> <span class="nx">StringDecoder</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'string_decoder'</span><span class="p">).</span><span class="nx">StringDecoder</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">parseHeader</span><span class="p">(</span><span class="nx">stream</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">stream</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'error'</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>
  <span class="nx">stream</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'readable'</span><span class="p">,</span> <span class="nx">onReadable</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">decoder</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">StringDecoder</span><span class="p">(</span><span class="s1">'utf8'</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">header</span> <span class="o">=</span> <span class="s1">''</span><span class="p">;</span>
  <span class="kd">function</span> <span class="nx">onReadable</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">chunk</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="kc">null</span> <span class="o">!==</span> <span class="p">(</span><span class="nx">chunk</span> <span class="o">=</span> <span class="nx">stream</span><span class="p">.</span><span class="nx">read</span><span class="p">()))</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">str</span> <span class="o">=</span> <span class="nx">decoder</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="nx">chunk</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">str</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/</span><span class="se">\n\n</span><span class="sr">/</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// found the header boundary</span>
        <span class="kd">var</span> <span class="nx">split</span> <span class="o">=</span> <span class="nx">str</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="sr">/</span><span class="se">\n\n</span><span class="sr">/</span><span class="p">);</span>
        <span class="nx">header</span> <span class="o">+=</span> <span class="nx">split</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>
        <span class="kd">var</span> <span class="nx">remaining</span> <span class="o">=</span> <span class="nx">split</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">'\n\n'</span><span class="p">);</span>
        <span class="kd">var</span> <span class="nx">buf</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Buffer</span><span class="p">(</span><span class="nx">remaining</span><span class="p">,</span> <span class="s1">'utf8'</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">buf</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span>
          <span class="nx">stream</span><span class="p">.</span><span class="nx">unshift</span><span class="p">(</span><span class="nx">buf</span><span class="p">);</span>
        <span class="nx">stream</span><span class="p">.</span><span class="nx">removeListener</span><span class="p">(</span><span class="s1">'error'</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>
        <span class="nx">stream</span><span class="p">.</span><span class="nx">removeListener</span><span class="p">(</span><span class="s1">'readable'</span><span class="p">,</span> <span class="nx">onReadable</span><span class="p">);</span>
        <span class="c1">// now the body of the message can be read from the stream.</span>
        <span class="nx">callback</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">header</span><span class="p">,</span> <span class="nx">stream</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// still reading the header.</span>
        <span class="nx">header</span> <span class="o">+=</span> <span class="nx">str</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>Note that, unlike <a href="#stream_readable_push_chunk_encoding"><code class="prettyprint">stream.push(chunk)</code></a>, <code class="prettyprint">stream.unshift(chunk)</code>
will not end the reading process by resetting the internal reading state of the
stream. This can cause unexpected results if <code class="prettyprint">unshift()</code> is called during a
read (i.e. from within a <a href="#stream_readable_read_size_1"><code class="prettyprint">stream._read()</code></a> implementation on a
custom stream). Following the call to <code class="prettyprint">unshift()</code> with an immediate
<a href="#stream_readable_push_chunk_encoding"><code class="prettyprint">stream.push(&#39;&#39;)</code></a> will reset the reading state appropriately,
however it is best to simply avoid calling <code class="prettyprint">unshift()</code> while in the process of
performing a read.</p>

<h4 id="readable-wrap-stream">readable.wrap(stream)</h4>

<ul>
<li><code class="prettyprint">stream</code> {Stream} An &ldquo;old style&rdquo; readable stream</li>
</ul>

<p>Versions of Node.js prior to v0.10 had streams that did not implement the
entire Streams API as it is today. (See <a href="#stream_compatibility_with_older_node_js_versions">Compatibility</a> for
more information.)</p>

<p>If you are using an older Node.js library that emits <a href="#stream_event_data"><code class="prettyprint">&#39;data&#39;</code></a> events and
has a <a href="#stream_readable_pause"><code class="prettyprint">stream.pause()</code></a> method that is advisory only, then you
can use the <code class="prettyprint">wrap()</code> method to create a <a href="#stream_class_stream_readable">Readable</a> stream that uses the old
stream as its data source.</p>

<p>You will very rarely ever need to call this function, but it exists
as a convenience for interacting with old Node.js programs and libraries.</p>

<p>For example:</p>
<pre class="highlight javascript"><code><span class="kr">const</span> <span class="nx">OldReader</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./old-api-module.js'</span><span class="p">).</span><span class="nx">OldReader</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">Readable</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'stream'</span><span class="p">).</span><span class="nx">Readable</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">oreader</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">OldReader</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">myReader</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Readable</span><span class="p">().</span><span class="nx">wrap</span><span class="p">(</span><span class="nx">oreader</span><span class="p">);</span>

<span class="nx">myReader</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'readable'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">myReader</span><span class="p">.</span><span class="nx">read</span><span class="p">();</span> <span class="c1">// etc.</span>
<span class="p">});</span>
</code></pre>

<h3 id="class-stream-transform">Class: stream.Transform</h3>

<p>Transform streams are <a href="#stream_class_stream_duplex">Duplex</a> streams where the output is in some way
computed from the input. They implement both the <a href="#stream_class_stream_readable">Readable</a> and
<a href="#stream_class_stream_writable">Writable</a> interfaces.</p>

<p>Examples of Transform streams include:</p>

<ul>
<li><a href="zlib.html">zlib streams</a></li>
<li><a href="crypto.html">crypto streams</a></li>
</ul>

<h3 id="class-stream-writable">Class: stream.Writable</h3>

<!--type=class-->

<p>The Writable stream interface is an abstraction for a <em>destination</em>
that you are writing data <em>to</em>.</p>

<p>Examples of writable streams include:</p>

<ul>
<li><a href="https://nodejs.org/docs/v5.8.0/api/http.html#http_class_http_clientrequest">HTTP requests, on the client</a></li>
<li><a href="https://nodejs.org/docs/v5.8.0/api/http.html#http_class_http_serverresponse">HTTP responses, on the server</a></li>
<li><a href="https://nodejs.org/docs/v5.8.0/api/fs.html#fs_class_fs_writestream">fs write streams</a></li>
<li><a href="zlib.html">zlib streams</a></li>
<li><a href="crypto.html">crypto streams</a></li>
<li><a href="https://nodejs.org/docs/v5.8.0/api/net.html#net_class_net_socket">TCP sockets</a></li>
<li><a href="https://nodejs.org/docs/v5.8.0/api/child_process.html#child_process_child_stdin">child process stdin</a></li>
<li><a href="https://nodejs.org/docs/v5.8.0/api/process.html#process_process_stdout"><code class="prettyprint">process.stdout</code></a>, <a href="https://nodejs.org/docs/v5.8.0/api/process.html#process_process_stderr"><code class="prettyprint">process.stderr</code></a></li>
</ul>

<h4 id="event-39-drain-39">Event: &#39;drain&rsquo;</h4>

<p>If a <a href="#stream_writable_write_chunk_encoding_callback"><code class="prettyprint">stream.write(chunk)</code></a> call returns <code class="prettyprint">false</code>, then the
<code class="prettyprint">&#39;drain&#39;</code> event will indicate when it is appropriate to begin writing more data
to the stream.</p>
<pre class="highlight javascript"><code><span class="c1">// Write the data to the supplied writable stream one million times.</span>
<span class="c1">// Be attentive to back-pressure.</span>
<span class="kd">function</span> <span class="nx">writeOneMillionTimes</span><span class="p">(</span><span class="nx">writer</span><span class="p">,</span> <span class="nx">data</span><span class="p">,</span> <span class="nx">encoding</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1000000</span><span class="p">;</span>
  <span class="nx">write</span><span class="p">();</span>
  <span class="kd">function</span> <span class="nx">write</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">ok</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
      <span class="nx">i</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// last time!</span>
        <span class="nx">writer</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">encoding</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// see if we should continue, or wait</span>
        <span class="c1">// don't pass the callback, because we're not done yet.</span>
        <span class="nx">ok</span> <span class="o">=</span> <span class="nx">writer</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">encoding</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">ok</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// had to stop early!</span>
      <span class="c1">// write some more once it drains</span>
      <span class="nx">writer</span><span class="p">.</span><span class="nx">once</span><span class="p">(</span><span class="s1">'drain'</span><span class="p">,</span> <span class="nx">write</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<h4 id="event-39-error-39">Event: &#39;error&rsquo;</h4>

<ul>
<li>{Error}</li>
</ul>

<p>Emitted if there was an error when writing or piping data.</p>

<h4 id="event-39-finish-39">Event: &#39;finish&rsquo;</h4>

<p>When the <a href="#stream_writable_end_chunk_encoding_callback"><code class="prettyprint">stream.end()</code></a> method has been called, and all data has
been flushed to the underlying system, this event is emitted.</p>
<pre class="highlight javascript"><code><span class="kd">var</span> <span class="nx">writer</span> <span class="o">=</span> <span class="nx">getWritableStreamSomehow</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="nx">i</span> <span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">writer</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="s1">'hello, #${i}!\n'</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">writer</span><span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="s1">'this is the end\n'</span><span class="p">);</span>
<span class="nx">writer</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'finish'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="s1">'all writes are now complete.'</span><span class="p">);</span>
<span class="p">});</span>
</code></pre>

<h4 id="event-39-pipe-39">Event: &#39;pipe&rsquo;</h4>

<ul>
<li><code class="prettyprint">src</code> {stream.Readable} source stream that is piping to this writable</li>
</ul>

<p>This is emitted whenever the <a href="#stream_readable_pipe_destination_options"><code class="prettyprint">stream.pipe()</code></a> method is called on a readable
stream, adding this writable to its set of destinations.</p>
<pre class="highlight javascript"><code><span class="kd">var</span> <span class="nx">writer</span> <span class="o">=</span> <span class="nx">getWritableStreamSomehow</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">reader</span> <span class="o">=</span> <span class="nx">getReadableStreamSomehow</span><span class="p">();</span>
<span class="nx">writer</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'pipe'</span><span class="p">,</span> <span class="p">(</span><span class="nx">src</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="s1">'something is piping into the writer'</span><span class="p">);</span>
  <span class="nx">assert</span><span class="p">.</span><span class="nx">equal</span><span class="p">(</span><span class="nx">src</span><span class="p">,</span> <span class="nx">reader</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">reader</span><span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">writer</span><span class="p">);</span>
</code></pre>

<h4 id="event-39-unpipe-39">Event: &#39;unpipe&rsquo;</h4>

<ul>
<li><code class="prettyprint">src</code> {<a href="#stream_class_stream_readable">Readable</a> Stream} The source stream that
<a href="#stream_readable_unpipe_destination">unpiped</a> this writable</li>
</ul>

<p>This is emitted whenever the <a href="#stream_readable_unpipe_destination"><code class="prettyprint">stream.unpipe()</code></a> method is called on a
readable stream, removing this writable from its set of destinations.</p>
<pre class="highlight javascript"><code><span class="kd">var</span> <span class="nx">writer</span> <span class="o">=</span> <span class="nx">getWritableStreamSomehow</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">reader</span> <span class="o">=</span> <span class="nx">getReadableStreamSomehow</span><span class="p">();</span>
<span class="nx">writer</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'unpipe'</span><span class="p">,</span> <span class="p">(</span><span class="nx">src</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="s1">'something has stopped piping into the writer'</span><span class="p">);</span>
  <span class="nx">assert</span><span class="p">.</span><span class="nx">equal</span><span class="p">(</span><span class="nx">src</span><span class="p">,</span> <span class="nx">reader</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">reader</span><span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">writer</span><span class="p">);</span>
<span class="nx">reader</span><span class="p">.</span><span class="nx">unpipe</span><span class="p">(</span><span class="nx">writer</span><span class="p">);</span>
</code></pre>

<h4 id="writable-cork">writable.cork()</h4>

<p>Forces buffering of all writes.</p>

<p>Buffered data will be flushed either at <a href="#stream_writable_uncork"><code class="prettyprint">stream.uncork()</code></a> or at
<a href="#stream_writable_end_chunk_encoding_callback"><code class="prettyprint">stream.end()</code></a> call.</p>

<h4 id="writable-end-chunk-encoding-callback">writable.end([chunk][, encoding][, callback])</h4>

<ul>
<li><code class="prettyprint">chunk</code> {String|Buffer} Optional data to write</li>
<li><code class="prettyprint">encoding</code> {String} The encoding, if <code class="prettyprint">chunk</code> is a String</li>
<li><code class="prettyprint">callback</code> {Function} Optional callback for when the stream is finished</li>
</ul>

<p>Call this method when no more data will be written to the stream. If supplied,
the callback is attached as a listener on the <a href="#stream_event_finish"><code class="prettyprint">&#39;finish&#39;</code></a> event.</p>

<p>Calling <a href="#stream_writable_write_chunk_encoding_callback"><code class="prettyprint">stream.write()</code></a> after calling
<a href="#stream_writable_end_chunk_encoding_callback"><code class="prettyprint">stream.end()</code></a> will raise an error.</p>
<pre class="highlight javascript"><code><span class="c1">// write 'hello, ' and then end with 'world!'</span>
<span class="kd">var</span> <span class="nx">file</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">createWriteStream</span><span class="p">(</span><span class="s1">'example.txt'</span><span class="p">);</span>
<span class="nx">file</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="s1">'hello, '</span><span class="p">);</span>
<span class="nx">file</span><span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="s1">'world!'</span><span class="p">);</span>
<span class="c1">// writing more now is not allowed!</span>
</code></pre>

<h4 id="writable-setdefaultencoding-encoding">writable.setDefaultEncoding(encoding)</h4>

<ul>
<li><code class="prettyprint">encoding</code> {String} The new default encoding</li>
</ul>

<p>Sets the default encoding for a writable stream.</p>

<h4 id="writable-uncork">writable.uncork()</h4>

<p>Flush all data, buffered since <a href="#stream_writable_cork"><code class="prettyprint">stream.cork()</code></a> call.</p>

<h4 id="writable-write-chunk-encoding-callback">writable.write(chunk[, encoding][, callback])</h4>

<ul>
<li><code class="prettyprint">chunk</code> {String|Buffer} The data to write</li>
<li><code class="prettyprint">encoding</code> {String} The encoding, if <code class="prettyprint">chunk</code> is a String</li>
<li><code class="prettyprint">callback</code> {Function} Callback for when this chunk of data is flushed</li>
<li>Returns: {Boolean} <code class="prettyprint">true</code> if the data was handled completely.</li>
</ul>

<p>This method writes some data to the underlying system, and calls the
supplied callback once the data has been fully handled.</p>

<p>The return value indicates if you should continue writing right now.
If the data had to be buffered internally, then it will return
<code class="prettyprint">false</code>. Otherwise, it will return <code class="prettyprint">true</code>.</p>

<p>This return value is strictly advisory. You MAY continue to write,
even if it returns <code class="prettyprint">false</code>. However, writes will be buffered in
memory, so it is best not to do this excessively. Instead, wait for
the <a href="#stream_event_drain"><code class="prettyprint">&#39;drain&#39;</code></a> event before writing more data.</p>

<h2 id="api-for-stream-implementors">API for Stream Implementors</h2>

<!--type=misc-->

<p>To implement any sort of stream, the pattern is the same:</p>

<ol>
<li>Extend the appropriate parent class in your own subclass. (The
<a href="https://nodejs.org/docs/v5.8.0/api/util.html#util_util_inherits_constructor_superconstructor"><code class="prettyprint">util.inherits()</code></a> method is particularly helpful for this.)</li>
<li>Call the appropriate parent class constructor in your constructor,
to be sure that the internal mechanisms are set up properly.</li>
<li>Implement one or more specific methods, as detailed below.</li>
</ol>

<p>The class to extend and the method(s) to implement depend on the sort
of stream class you are writing:</p>

<table>
  <thead>
    <tr>
      <th>
        <p>Use-case</p>
      </th>
      <th>
        <p>Class</p>
      </th>
      <th>
        <p>Method(s) to implement</p>
      </th>
    </tr>
  </thead>
  <tr>
    <td>
      <p>Reading only</p>
    </td>
    <td>
      <p>[Readable](#stream_class_stream_readable_1)</p>
    </td>
    <td>
      <p><code>[_read][stream-_read]</code></p>
    </td>
  </tr>
  <tr>
    <td>
      <p>Writing only</p>
    </td>
    <td>
      <p>[Writable](#stream_class_stream_writable_1)</p>
    </td>
    <td>
      <p><code>[_write][stream-_write]</code>, <code>[_writev][stream-_writev]</code></p>
    </td>
  </tr>
  <tr>
    <td>
      <p>Reading and writing</p>
    </td>
    <td>
      <p>[Duplex](#stream_class_stream_duplex_1)</p>
    </td>
    <td>
      <p><code>[_read][stream-_read]</code>, <code>[_write][stream-_write]</code>, <code>[_writev][stream-_writev]</code></p>
    </td>
  </tr>
  <tr>
    <td>
      <p>Operate on written data, then read the result</p>
    </td>
    <td>
      <p>[Transform](#stream_class_stream_transform_1)</p>
    </td>
    <td>
      <p><code>[_transform][stream-_transform]</code>, <code>[_flush][stream-_flush]</code></p>
    </td>
  </tr>
</table>

<p>In your implementation code, it is very important to never call the methods
described in <a href="#stream_api_for_stream_consumers">API for Stream Consumers</a>. Otherwise, you can potentially cause
adverse side effects in programs that consume your streaming interfaces.</p>

<h3 id="class-stream-duplex">Class: stream.Duplex</h3>

<!--type=class-->

<p>A &ldquo;duplex&rdquo; stream is one that is both Readable and Writable, such as a TCP
socket connection.</p>

<p>Note that <code class="prettyprint">stream.Duplex</code> is an abstract class designed to be extended
with an underlying implementation of the <a href="#stream_readable_read_size_1"><code class="prettyprint">stream._read(size)</code></a>
and <a href="#stream_writable_write_chunk_encoding_callback_1"><code class="prettyprint">stream._write(chunk, encoding, callback)</code></a> methods as you
would with a Readable or Writable stream class.</p>

<p>Since JavaScript doesn&rsquo;t have multiple prototypal inheritance, this class
prototypally inherits from Readable, and then parasitically from Writable. It is
thus up to the user to implement both the low-level
<a href="#stream_readable_read_size_1"><code class="prettyprint">stream._read(n)</code></a> method as well as the low-level
<a href="#stream_writable_write_chunk_encoding_callback_1"><code class="prettyprint">stream._write(chunk, encoding, callback)</code></a> method on extension
duplex classes.</p>

<h4 id="new-stream-duplex-options">new stream.Duplex(options)</h4>

<ul>
<li><code class="prettyprint">options</code> {Object} Passed to both Writable and Readable
constructors. Also has the following fields:

<ul>
<li><code class="prettyprint">allowHalfOpen</code> {Boolean} Default = <code class="prettyprint">true</code>. If set to <code class="prettyprint">false</code>, then
the stream will automatically end the readable side when the
writable side ends and vice versa.</li>
<li><code class="prettyprint">readableObjectMode</code> {Boolean} Default = <code class="prettyprint">false</code>. Sets <code class="prettyprint">objectMode</code>
for readable side of the stream. Has no effect if <code class="prettyprint">objectMode</code>
is <code class="prettyprint">true</code>.</li>
<li><code class="prettyprint">writableObjectMode</code> {Boolean} Default = <code class="prettyprint">false</code>. Sets <code class="prettyprint">objectMode</code>
for writable side of the stream. Has no effect if <code class="prettyprint">objectMode</code>
is <code class="prettyprint">true</code>.</li>
</ul></li>
</ul>

<p>In classes that extend the Duplex class, make sure to call the
constructor so that the buffering settings can be properly
initialized.</p>

<h3 id="class-stream-passthrough">Class: stream.PassThrough</h3>

<p>This is a trivial implementation of a <a href="#stream_class_stream_transform">Transform</a> stream that simply
passes the input bytes across to the output. Its purpose is mainly
for examples and testing, but there are occasionally use cases where
it can come in handy as a building block for novel sorts of streams.</p>

<h3 id="class-stream-readable">Class: stream.Readable</h3>

<!--type=class-->

<p><code class="prettyprint">stream.Readable</code> is an abstract class designed to be extended with an
underlying implementation of the <a href="#stream_readable_read_size_1"><code class="prettyprint">stream._read(size)</code></a> method.</p>

<p>Please see <a href="#stream_api_for_stream_consumers">API for Stream Consumers</a> for how to consume
streams in your programs. What follows is an explanation of how to
implement Readable streams in your programs.</p>

<h4 id="new-stream-readable-options">new stream.Readable([options])</h4>

<ul>
<li><code class="prettyprint">options</code> {Object}

<ul>
<li><code class="prettyprint">highWaterMark</code> {Number} The maximum number of bytes to store in
the internal buffer before ceasing to read from the underlying
resource. Default = <code class="prettyprint">16384</code> (16kb), or <code class="prettyprint">16</code> for <code class="prettyprint">objectMode</code> streams</li>
<li><code class="prettyprint">encoding</code> {String} If specified, then buffers will be decoded to
strings using the specified encoding. Default = <code class="prettyprint">null</code></li>
<li><code class="prettyprint">objectMode</code> {Boolean} Whether this stream should behave
as a stream of objects. Meaning that <a href="#stream_readable_read_size"><code class="prettyprint">stream.read(n)</code></a> returns
a single value instead of a Buffer of size n. Default = <code class="prettyprint">false</code></li>
<li><code class="prettyprint">read</code> {Function} Implementation for the <a href="#stream_readable_read_size_1"><code class="prettyprint">stream._read()</code></a>
method.</li>
</ul></li>
</ul>

<p>In classes that extend the Readable class, make sure to call the
Readable constructor so that the buffering settings can be properly
initialized.</p>

<h4 id="readable-_read-size">readable._read(size)</h4>

<ul>
<li><code class="prettyprint">size</code> {Number} Number of bytes to read asynchronously</li>
</ul>

<p>Note: <strong>Implement this method, but do NOT call it directly.</strong></p>

<p>This method is prefixed with an underscore because it is internal to the
class that defines it and should only be called by the internal Readable
class methods. All Readable stream implementations must provide a _read
method to fetch data from the underlying resource.</p>

<p>When <code class="prettyprint">_read()</code> is called, if data is available from the resource, the <code class="prettyprint">_read()</code>
implementation should start pushing that data into the read queue by calling
<a href="#stream_readable_push_chunk_encoding"><code class="prettyprint">this.push(dataChunk)</code></a>. <code class="prettyprint">_read()</code> should continue reading from
the resource and pushing data until push returns <code class="prettyprint">false</code>, at which point it
should stop reading from the resource. Only when <code class="prettyprint">_read()</code> is called again after
it has stopped should it start reading more data from the resource and pushing
that data onto the queue.</p>

<p>Note: once the <code class="prettyprint">_read()</code> method is called, it will not be called again until
the <a href="#stream_readable_push_chunk_encoding"><code class="prettyprint">stream.push()</code></a> method is called.</p>

<p>The <code class="prettyprint">size</code> argument is advisory. Implementations where a &ldquo;read&rdquo; is a
single call that returns data can use this to know how much data to
fetch. Implementations where that is not relevant, such as TCP or
TLS, may ignore this argument, and simply provide data whenever it
becomes available. There is no need, for example to &ldquo;wait&rdquo; until
<code class="prettyprint">size</code> bytes are available before calling <a href="#stream_readable_push_chunk_encoding"><code class="prettyprint">stream.push(chunk)</code></a>.</p>

<h4 id="readable-push-chunk-encoding">readable.push(chunk[, encoding])</h4>

<ul>
<li><code class="prettyprint">chunk</code> {Buffer|Null|String} Chunk of data to push into the read queue</li>
<li><code class="prettyprint">encoding</code> {String} Encoding of String chunks.  Must be a valid
Buffer encoding, such as <code class="prettyprint">&#39;utf8&#39;</code> or <code class="prettyprint">&#39;ascii&#39;</code></li>
<li>return {Boolean} Whether or not more pushes should be performed</li>
</ul>

<p>Note: <strong>This method should be called by Readable implementors, NOT
by consumers of Readable streams.</strong></p>

<p>If a value other than null is passed, The <code class="prettyprint">push()</code> method adds a chunk of data
into the queue for subsequent stream processors to consume. If <code class="prettyprint">null</code> is
passed, it signals the end of the stream (EOF), after which no more data
can be written.</p>

<p>The data added with <code class="prettyprint">push()</code> can be pulled out by calling the
<a href="#stream_readable_read_size"><code class="prettyprint">stream.read()</code></a> method when the <a href="#stream_event_readable"><code class="prettyprint">&#39;readable&#39;</code></a> event fires.</p>

<p>This API is designed to be as flexible as possible. For example,
you may be wrapping a lower-level source which has some sort of
pause/resume mechanism, and a data callback. In those cases, you
could wrap the low-level source object by doing something like this:</p>
<pre class="highlight javascript"><code><span class="c1">// source is an object with readStop() and readStart() methods,</span>
<span class="c1">// and an `ondata` member that gets called when it has data, and</span>
<span class="c1">// an `onend` member that gets called when the data is over.</span>

<span class="nx">util</span><span class="p">.</span><span class="nx">inherits</span><span class="p">(</span><span class="nx">SourceWrapper</span><span class="p">,</span> <span class="nx">Readable</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">SourceWrapper</span><span class="p">(</span><span class="nx">options</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">Readable</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">options</span><span class="p">);</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">_source</span> <span class="o">=</span> <span class="nx">getLowlevelSourceObject</span><span class="p">();</span>

  <span class="c1">// Every time there's data, we push it into the internal buffer.</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_source</span><span class="p">.</span><span class="nx">ondata</span> <span class="o">=</span> <span class="p">(</span><span class="nx">chunk</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// if push() returns false, then we need to stop reading from source</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">chunk</span><span class="p">))</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">_source</span><span class="p">.</span><span class="nx">readStop</span><span class="p">();</span>
  <span class="p">};</span>

  <span class="c1">// When the source ends, we push the EOF-signaling `null` chunk</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_source</span><span class="p">.</span><span class="nx">onend</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="c1">// _read will be called when the stream wants to pull more data in</span>
<span class="c1">// the advisory size argument is ignored in this case.</span>
<span class="nx">SourceWrapper</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">_read</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_source</span><span class="p">.</span><span class="nx">readStart</span><span class="p">();</span>
<span class="p">};</span>
</code></pre>

<h4 id="example-a-counting-stream">Example: A Counting Stream</h4>

<!--type=example-->

<p>This is a basic example of a Readable stream. It emits the numerals
from 1 to 1,000,000 in ascending order, and then ends.</p>
<pre class="highlight javascript"><code><span class="kr">const</span> <span class="nx">Readable</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'stream'</span><span class="p">).</span><span class="nx">Readable</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">util</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'util'</span><span class="p">);</span>
<span class="nx">util</span><span class="p">.</span><span class="nx">inherits</span><span class="p">(</span><span class="nx">Counter</span><span class="p">,</span> <span class="nx">Readable</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">Counter</span><span class="p">(</span><span class="nx">opt</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">Readable</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">opt</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_max</span> <span class="o">=</span> <span class="mi">1000000</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">Counter</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">_read</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_index</span><span class="o">++</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">_max</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">str</span> <span class="o">=</span> <span class="s1">''</span> <span class="o">+</span> <span class="nx">i</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">buf</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Buffer</span><span class="p">(</span><span class="nx">str</span><span class="p">,</span> <span class="s1">'ascii'</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">buf</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre>

<h4 id="example-simpleprotocol-v1-sub-optimal">Example: SimpleProtocol v1 (Sub-optimal)</h4>

<p>This is similar to the <code class="prettyprint">parseHeader</code> function described
<a href="#stream_readable_unshift_chunk">here</a>, but implemented as a custom stream.
Also, note that this implementation does not convert the incoming data to a
string.</p>

<p>However, this would be better implemented as a <a href="#stream_class_stream_transform">Transform</a> stream. See
<a href="#stream_example_simpleprotocol_parser_v2">SimpleProtocol v2</a> for a better implementation.</p>
<pre class="highlight javascript"><code><span class="c1">// A parser for a simple data protocol.</span>
<span class="c1">// The "header" is a JSON object, followed by 2 \n characters, and</span>
<span class="c1">// then a message body.</span>
<span class="c1">//</span>
<span class="c1">// NOTE: This can be done more simply as a Transform stream!</span>
<span class="c1">// Using Readable directly for this is sub-optimal. See the</span>
<span class="c1">// alternative example below under the Transform section.</span>

<span class="kr">const</span> <span class="nx">Readable</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'stream'</span><span class="p">).</span><span class="nx">Readable</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">util</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'util'</span><span class="p">);</span>

<span class="nx">util</span><span class="p">.</span><span class="nx">inherits</span><span class="p">(</span><span class="nx">SimpleProtocol</span><span class="p">,</span> <span class="nx">Readable</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">SimpleProtocol</span><span class="p">(</span><span class="nx">source</span><span class="p">,</span> <span class="nx">options</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="k">this</span> <span class="k">instanceof</span> <span class="nx">SimpleProtocol</span><span class="p">))</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">SimpleProtocol</span><span class="p">(</span><span class="nx">source</span><span class="p">,</span> <span class="nx">options</span><span class="p">);</span>

  <span class="nx">Readable</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">options</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_inBody</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_sawFirstCr</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>

  <span class="c1">// source is a readable stream, such as a socket or file</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_source</span> <span class="o">=</span> <span class="nx">source</span><span class="p">;</span>

  <span class="kd">var</span> <span class="nx">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="nx">source</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'end'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">self</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
  <span class="p">});</span>

  <span class="c1">// give it a kick whenever the source is readable</span>
  <span class="c1">// read(0) will not consume any bytes</span>
  <span class="nx">source</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'readable'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">self</span><span class="p">.</span><span class="nx">read</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">});</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">_rawHeader</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">header</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">SimpleProtocol</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">_read</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">_inBody</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">chunk</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_source</span><span class="p">.</span><span class="nx">read</span><span class="p">();</span>

    <span class="c1">// if the source doesn't have data, we don't have data yet.</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">chunk</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s1">''</span><span class="p">);</span>

    <span class="c1">// check if the chunk has a \n\n</span>
    <span class="kd">var</span> <span class="nx">split</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">chunk</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">chunk</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// '\n'</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_sawFirstCr</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">split</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">_sawFirstCr</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">_sawFirstCr</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">split</span> <span class="o">===</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// still waiting for the \n\n</span>
      <span class="c1">// stash the chunk, and try again.</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">_rawHeader</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">chunk</span><span class="p">);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s1">''</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">_inBody</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">h</span> <span class="o">=</span> <span class="nx">chunk</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">split</span><span class="p">);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">_rawHeader</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">h</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">header</span> <span class="o">=</span> <span class="nx">Buffer</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_rawHeader</span><span class="p">).</span><span class="nx">toString</span><span class="p">();</span>
      <span class="k">try</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">header</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">header</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">er</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="s1">'error'</span><span class="p">,</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'invalid simple protocol data'</span><span class="p">));</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// now, because we got some extra data, unshift the rest</span>
      <span class="c1">// back into the read queue so that our consumer will see it.</span>
      <span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">chunk</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">split</span><span class="p">);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">unshift</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span>
      <span class="c1">// calling unshift by itself does not reset the reading state</span>
      <span class="c1">// of the stream; since we're inside _read, doing an additional</span>
      <span class="c1">// push('') will reset the state appropriately.</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s1">''</span><span class="p">);</span>

      <span class="c1">// and let them know that we are done parsing the header.</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="s1">'header'</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">header</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// from there on, just provide the data to our consumer.</span>
    <span class="c1">// careful not to push(null), since that would indicate EOF.</span>
    <span class="kd">var</span> <span class="nx">chunk</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_source</span><span class="p">.</span><span class="nx">read</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">chunk</span><span class="p">)</span> <span class="k">this</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">chunk</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Usage:</span>
<span class="c1">// var parser = new SimpleProtocol(source);</span>
<span class="c1">// Now parser is a readable stream that will emit 'header'</span>
<span class="c1">// with the parsed header data.</span>
</code></pre>

<h3 id="class-stream-transform">Class: stream.Transform</h3>

<p>A &ldquo;transform&rdquo; stream is a duplex stream where the output is causally
connected in some way to the input, such as a <a href="zlib.html">zlib</a> stream or a
<a href="crypto.html">crypto</a> stream.</p>

<p>There is no requirement that the output be the same size as the input,
the same number of chunks, or arrive at the same time. For example, a
Hash stream will only ever have a single chunk of output which is
provided when the input is ended. A zlib stream will produce output
that is either much smaller or much larger than its input.</p>

<p>Rather than implement the <a href="#stream_readable_read_size_1"><code class="prettyprint">stream._read()</code></a> and
<a href="#stream_writable_write_chunk_encoding_callback_1"><code class="prettyprint">stream._write()</code></a> methods, Transform classes must implement the
<a href="#stream_transform_transform_chunk_encoding_callback"><code class="prettyprint">stream._transform()</code></a> method, and may optionally
also implement the <a href="#stream_transform_flush_callback"><code class="prettyprint">stream._flush()</code></a> method. (See below.)</p>

<h4 id="new-stream-transform-options">new stream.Transform([options])</h4>

<ul>
<li><code class="prettyprint">options</code> {Object} Passed to both Writable and Readable
constructors. Also has the following fields:

<ul>
<li><code class="prettyprint">transform</code> {Function} Implementation for the
<a href="#stream_transform_transform_chunk_encoding_callback"><code class="prettyprint">stream._transform()</code></a> method.</li>
<li><code class="prettyprint">flush</code> {Function} Implementation for the <a href="#stream_transform_flush_callback"><code class="prettyprint">stream._flush()</code></a>
method.</li>
</ul></li>
</ul>

<p>In classes that extend the Transform class, make sure to call the
constructor so that the buffering settings can be properly
initialized.</p>

<h4 id="events-39-finish-39-and-39-end-39">Events: &#39;finish&rsquo; and &#39;end&rsquo;</h4>

<p>The <a href="#stream_event_finish"><code class="prettyprint">&#39;finish&#39;</code></a> and <a href="#stream_event_end"><code class="prettyprint">&#39;end&#39;</code></a> events are from the parent Writable
and Readable classes respectively. The <code class="prettyprint">&#39;finish&#39;</code> event is fired after
<a href="#stream_writable_end_chunk_encoding_callback"><code class="prettyprint">stream.end()</code></a> is called and all chunks have been processed by
<a href="#stream_transform_transform_chunk_encoding_callback"><code class="prettyprint">stream._transform()</code></a>, <code class="prettyprint">&#39;end&#39;</code> is fired after all data has
been output which is after the callback in <a href="#stream_transform_flush_callback"><code class="prettyprint">stream._flush()</code></a>
has been called.</p>

<h4 id="transform-_flush-callback">transform._flush(callback)</h4>

<ul>
<li><code class="prettyprint">callback</code> {Function} Call this function (optionally with an error
argument) when you are done flushing any remaining data.</li>
</ul>

<p>Note: <strong>This function MUST NOT be called directly.</strong>  It MAY be implemented
by child classes, and if so, will be called by the internal Transform
class methods only.</p>

<p>In some cases, your transform operation may need to emit a bit more
data at the end of the stream. For example, a <code class="prettyprint">Zlib</code> compression
stream will store up some internal state so that it can optimally
compress the output. At the end, however, it needs to do the best it
can with what is left, so that the data will be complete.</p>

<p>In those cases, you can implement a <code class="prettyprint">_flush()</code> method, which will be
called at the very end, after all the written data is consumed, but
before emitting <a href="#stream_event_end"><code class="prettyprint">&#39;end&#39;</code></a> to signal the end of the readable side. Just
like with <a href="#stream_transform_transform_chunk_encoding_callback"><code class="prettyprint">stream._transform()</code></a>, call
<code class="prettyprint">transform.push(chunk)</code> zero or more times, as appropriate, and call <code class="prettyprint">callback</code>
when the flush operation is complete.</p>

<p>This method is prefixed with an underscore because it is internal to
the class that defines it, and should not be called directly by user
programs. However, you <strong>are</strong> expected to override this method in
your own extension classes.</p>

<h4 id="transform-_transform-chunk-encoding-callback">transform._transform(chunk, encoding, callback)</h4>

<ul>
<li><code class="prettyprint">chunk</code> {Buffer|String} The chunk to be transformed. Will <strong>always</strong>
be a buffer unless the <code class="prettyprint">decodeStrings</code> option was set to <code class="prettyprint">false</code>.</li>
<li><code class="prettyprint">encoding</code> {String} If the chunk is a string, then this is the
encoding type. If chunk is a buffer, then this is the special
value - &#39;buffer&rsquo;, ignore it in this case.</li>
<li><code class="prettyprint">callback</code> {Function} Call this function (optionally with an error
argument and data) when you are done processing the supplied chunk.</li>
</ul>

<p>Note: <strong>This function MUST NOT be called directly.</strong>  It should be
implemented by child classes, and called by the internal Transform
class methods only.</p>

<p>All Transform stream implementations must provide a <code class="prettyprint">_transform()</code>
method to accept input and produce output.</p>

<p><code class="prettyprint">_transform()</code> should do whatever has to be done in this specific
Transform class, to handle the bytes being written, and pass them off
to the readable portion of the interface. Do asynchronous I/O,
process things, and so on.</p>

<p>Call <code class="prettyprint">transform.push(outputChunk)</code> 0 or more times to generate output
from this input chunk, depending on how much data you want to output
as a result of this chunk.</p>

<p>Call the callback function only when the current chunk is completely
consumed. Note that there may or may not be output as a result of any
particular input chunk. If you supply a second argument to the callback
it will be passed to the push method. In other words the following are
equivalent:</p>
<pre class="highlight javascript"><code><span class="nx">transform</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">_transform</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">encoding</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
  <span class="nx">callback</span><span class="p">();</span>
<span class="p">};</span>

<span class="nx">transform</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">_transform</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">encoding</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">callback</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">data</span><span class="p">);</span>
<span class="p">};</span>
</code></pre>

<p>This method is prefixed with an underscore because it is internal to
the class that defines it, and should not be called directly by user
programs. However, you <strong>are</strong> expected to override this method in
your own extension classes.</p>

<h4 id="example-simpleprotocol-parser-v2">Example: <code class="prettyprint">SimpleProtocol</code> parser v2</h4>

<p>The example <a href="#stream_example_simpleprotocol_v1_sub_optimal">here</a> of a simple
protocol parser can be implemented simply by using the higher level
<a href="#stream_class_stream_transform">Transform</a> stream class, similar to the <code class="prettyprint">parseHeader</code> and <code class="prettyprint">SimpleProtocol
v1</code> examples.</p>

<p>In this example, rather than providing the input as an argument, it
would be piped into the parser, which is a more idiomatic Node.js stream
approach.</p>
<pre class="highlight javascript"><code><span class="kr">const</span> <span class="nx">util</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'util'</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">Transform</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'stream'</span><span class="p">).</span><span class="nx">Transform</span><span class="p">;</span>
<span class="nx">util</span><span class="p">.</span><span class="nx">inherits</span><span class="p">(</span><span class="nx">SimpleProtocol</span><span class="p">,</span> <span class="nx">Transform</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">SimpleProtocol</span><span class="p">(</span><span class="nx">options</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="k">this</span> <span class="k">instanceof</span> <span class="nx">SimpleProtocol</span><span class="p">))</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">SimpleProtocol</span><span class="p">(</span><span class="nx">options</span><span class="p">);</span>

  <span class="nx">Transform</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">options</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_inBody</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_sawFirstCr</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_rawHeader</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">header</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">SimpleProtocol</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">_transform</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">chunk</span><span class="p">,</span> <span class="nx">encoding</span><span class="p">,</span> <span class="nx">done</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">_inBody</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// check if the chunk has a \n\n</span>
    <span class="kd">var</span> <span class="nx">split</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">chunk</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">chunk</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// '\n'</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_sawFirstCr</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">split</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">_sawFirstCr</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">_sawFirstCr</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">split</span> <span class="o">===</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// still waiting for the \n\n</span>
      <span class="c1">// stash the chunk, and try again.</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">_rawHeader</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">chunk</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">_inBody</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">h</span> <span class="o">=</span> <span class="nx">chunk</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">split</span><span class="p">);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">_rawHeader</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">h</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">header</span> <span class="o">=</span> <span class="nx">Buffer</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_rawHeader</span><span class="p">).</span><span class="nx">toString</span><span class="p">();</span>
      <span class="k">try</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">header</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">header</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">er</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="s1">'error'</span><span class="p">,</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'invalid simple protocol data'</span><span class="p">));</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// and let them know that we are done parsing the header.</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="s1">'header'</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">header</span><span class="p">);</span>

      <span class="c1">// now, because we got some extra data, emit this first.</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">chunk</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">split</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// from there on, just provide the data to our consumer as-is.</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">chunk</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">done</span><span class="p">();</span>
<span class="p">};</span>

<span class="c1">// Usage:</span>
<span class="c1">// var parser = new SimpleProtocol();</span>
<span class="c1">// source.pipe(parser)</span>
<span class="c1">// Now parser is a readable stream that will emit 'header'</span>
<span class="c1">// with the parsed header data.</span>
</code></pre>

<h3 id="class-stream-writable">Class: stream.Writable</h3>

<!--type=class-->

<p><code class="prettyprint">stream.Writable</code> is an abstract class designed to be extended with an
underlying implementation of the
<a href="#stream_writable_write_chunk_encoding_callback_1"><code class="prettyprint">stream._write(chunk, encoding, callback)</code></a> method.</p>

<p>Please see <a href="#stream_api_for_stream_consumers">API for Stream Consumers</a> for how to consume
writable streams in your programs. What follows is an explanation of
how to implement Writable streams in your programs.</p>

<h4 id="new-stream-writable-options">new stream.Writable([options])</h4>

<ul>
<li><code class="prettyprint">options</code> {Object}

<ul>
<li><code class="prettyprint">highWaterMark</code> {Number} Buffer level when
<a href="#stream_writable_write_chunk_encoding_callback"><code class="prettyprint">stream.write()</code></a> starts returning <code class="prettyprint">false</code>. Default = <code class="prettyprint">16384</code>
(16kb), or <code class="prettyprint">16</code> for <code class="prettyprint">objectMode</code> streams.</li>
<li><code class="prettyprint">decodeStrings</code> {Boolean} Whether or not to decode strings into
Buffers before passing them to <a href="#stream_writable_write_chunk_encoding_callback_1"><code class="prettyprint">stream._write()</code></a>.
Default = <code class="prettyprint">true</code></li>
<li><code class="prettyprint">objectMode</code> {Boolean} Whether or not the
<a href="#stream_writable_write_chunk_encoding_callback"><code class="prettyprint">stream.write(anyObj)</code></a> is a valid operation. If set you can
write arbitrary data instead of only <code class="prettyprint">Buffer</code> / <code class="prettyprint">String</code> data.
Default = <code class="prettyprint">false</code></li>
<li><code class="prettyprint">write</code> {Function} Implementation for the
<a href="#stream_writable_write_chunk_encoding_callback_1"><code class="prettyprint">stream._write()</code></a> method.</li>
<li><code class="prettyprint">writev</code> {Function} Implementation for the
<a href="#stream_writable_writev_chunks_callback"><code class="prettyprint">stream._writev()</code></a> method.</li>
</ul></li>
</ul>

<p>In classes that extend the Writable class, make sure to call the
constructor so that the buffering settings can be properly
initialized.</p>

<h4 id="writable-_write-chunk-encoding-callback">writable._write(chunk, encoding, callback)</h4>

<ul>
<li><code class="prettyprint">chunk</code> {Buffer|String} The chunk to be written. Will <strong>always</strong>
be a buffer unless the <code class="prettyprint">decodeStrings</code> option was set to <code class="prettyprint">false</code>.</li>
<li><code class="prettyprint">encoding</code> {String} If the chunk is a string, then this is the
encoding type. If chunk is a buffer, then this is the special
value - &#39;buffer&rsquo;, ignore it in this case.</li>
<li><code class="prettyprint">callback</code> {Function} Call this function (optionally with an error
argument) when you are done processing the supplied chunk.</li>
</ul>

<p>All Writable stream implementations must provide a
<a href="#stream_writable_write_chunk_encoding_callback_1"><code class="prettyprint">stream._write()</code></a> method to send data to the underlying
resource.</p>

<p>Note: <strong>This function MUST NOT be called directly.</strong>  It should be
implemented by child classes, and called by the internal Writable
class methods only.</p>

<p>Call the callback using the standard <code class="prettyprint">callback(error)</code> pattern to
signal that the write completed successfully or with an error.</p>

<p>If the <code class="prettyprint">decodeStrings</code> flag is set in the constructor options, then
<code class="prettyprint">chunk</code> may be a string rather than a Buffer, and <code class="prettyprint">encoding</code> will
indicate the sort of string that it is. This is to support
implementations that have an optimized handling for certain string
data encodings. If you do not explicitly set the <code class="prettyprint">decodeStrings</code>
option to <code class="prettyprint">false</code>, then you can safely ignore the <code class="prettyprint">encoding</code> argument,
and assume that <code class="prettyprint">chunk</code> will always be a Buffer.</p>

<p>This method is prefixed with an underscore because it is internal to
the class that defines it, and should not be called directly by user
programs. However, you <strong>are</strong> expected to override this method in
your own extension classes.</p>

<h4 id="writable-_writev-chunks-callback">writable._writev(chunks, callback)</h4>

<ul>
<li><code class="prettyprint">chunks</code> {Array} The chunks to be written. Each chunk has following
format: <code class="prettyprint">{ chunk: ..., encoding: ... }</code>.</li>
<li><code class="prettyprint">callback</code> {Function} Call this function (optionally with an error
argument) when you are done processing the supplied chunks.</li>
</ul>

<p>Note: <strong>This function MUST NOT be called directly.</strong>  It may be
implemented by child classes, and called by the internal Writable
class methods only.</p>

<p>This function is completely optional to implement. In most cases it is
unnecessary. If implemented, it will be called with all the chunks
that are buffered in the write queue.</p>

<h2 id="simplified-constructor-api">Simplified Constructor API</h2>

<!--type=misc-->

<p>In simple cases there is now the added benefit of being able to construct a
stream without inheritance.</p>

<p>This can be done by passing the appropriate methods as constructor options:</p>

<p>Examples:</p>

<h3 id="duplex">Duplex</h3>
<pre class="highlight javascript"><code><span class="kd">var</span> <span class="nx">duplex</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">stream</span><span class="p">.</span><span class="nx">Duplex</span><span class="p">({</span>
  <span class="na">read</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// sets this._read under the hood</span>

    <span class="c1">// push data onto the read queue, passing null</span>
    <span class="c1">// will signal the end of the stream (EOF)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">chunk</span><span class="p">);</span>
  <span class="p">},</span>
  <span class="na">write</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">chunk</span><span class="p">,</span> <span class="nx">encoding</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// sets this._write under the hood</span>

    <span class="c1">// An optional error can be passed as the first argument</span>
    <span class="nx">next</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="c1">// or</span>

<span class="kd">var</span> <span class="nx">duplex</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">stream</span><span class="p">.</span><span class="nx">Duplex</span><span class="p">({</span>
  <span class="na">read</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// sets this._read under the hood</span>

    <span class="c1">// push data onto the read queue, passing null</span>
    <span class="c1">// will signal the end of the stream (EOF)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">chunk</span><span class="p">);</span>
  <span class="p">},</span>
  <span class="na">writev</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">chunks</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// sets this._writev under the hood</span>

    <span class="c1">// An optional error can be passed as the first argument</span>
    <span class="nx">next</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre>

<h3 id="readable">Readable</h3>
<pre class="highlight javascript"><code><span class="kd">var</span> <span class="nx">readable</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">stream</span><span class="p">.</span><span class="nx">Readable</span><span class="p">({</span>
  <span class="na">read</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// sets this._read under the hood</span>

    <span class="c1">// push data onto the read queue, passing null</span>
    <span class="c1">// will signal the end of the stream (EOF)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">chunk</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre>

<h3 id="transform">Transform</h3>
<pre class="highlight javascript"><code><span class="kd">var</span> <span class="nx">transform</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">stream</span><span class="p">.</span><span class="nx">Transform</span><span class="p">({</span>
  <span class="na">transform</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">chunk</span><span class="p">,</span> <span class="nx">encoding</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// sets this._transform under the hood</span>

    <span class="c1">// generate output as many times as needed</span>
    <span class="c1">// this.push(chunk);</span>

    <span class="c1">// call when the current chunk is consumed</span>
    <span class="nx">next</span><span class="p">();</span>
  <span class="p">},</span>
  <span class="na">flush</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">done</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// sets this._flush under the hood</span>

    <span class="c1">// generate output as many times as needed</span>
    <span class="c1">// this.push(chunk);</span>

    <span class="nx">done</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre>

<h3 id="writable">Writable</h3>
<pre class="highlight javascript"><code><span class="kd">var</span> <span class="nx">writable</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">stream</span><span class="p">.</span><span class="nx">Writable</span><span class="p">({</span>
  <span class="na">write</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">chunk</span><span class="p">,</span> <span class="nx">encoding</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// sets this._write under the hood</span>

    <span class="c1">// An optional error can be passed as the first argument</span>
    <span class="nx">next</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="c1">// or</span>

<span class="kd">var</span> <span class="nx">writable</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">stream</span><span class="p">.</span><span class="nx">Writable</span><span class="p">({</span>
  <span class="na">writev</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">chunks</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// sets this._writev under the hood</span>

    <span class="c1">// An optional error can be passed as the first argument</span>
    <span class="nx">next</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre>

<h2 id="streams-under-the-hood">Streams: Under the Hood</h2>

<!--type=misc-->

<h3 id="buffering">Buffering</h3>

<!--type=misc-->

<p>Both Writable and Readable streams will buffer data on an internal
object which can be retrieved from <code class="prettyprint">_writableState.getBuffer()</code> or
<code class="prettyprint">_readableState.buffer</code>, respectively.</p>

<p>The amount of data that will potentially be buffered depends on the
<code class="prettyprint">highWaterMark</code> option which is passed into the constructor.</p>

<p>Buffering in Readable streams happens when the implementation calls
<a href="#stream_readable_push_chunk_encoding"><code class="prettyprint">stream.push(chunk)</code></a>. If the consumer of the Stream does not
call <a href="#stream_readable_read_size"><code class="prettyprint">stream.read()</code></a>, then the data will sit in the internal
queue until it is consumed.</p>

<p>Buffering in Writable streams happens when the user calls
<a href="#stream_writable_write_chunk_encoding_callback"><code class="prettyprint">stream.write(chunk)</code></a> repeatedly, even when it returns <code class="prettyprint">false</code>.</p>

<p>The purpose of streams, especially with the <a href="#stream_readable_pipe_destination_options"><code class="prettyprint">stream.pipe()</code></a> method, is to
limit the buffering of data to acceptable levels, so that sources and
destinations of varying speed will not overwhelm the available memory.</p>

<h3 id="compatibility-with-older-node-js-versions">Compatibility with Older Node.js Versions</h3>

<!--type=misc-->

<p>In versions of Node.js prior to v0.10, the Readable stream interface was
simpler, but also less powerful and less useful.</p>

<ul>
<li>Rather than waiting for you to call the <a href="#stream_readable_read_size"><code class="prettyprint">stream.read()</code></a> method,
<a href="#stream_event_data"><code class="prettyprint">&#39;data&#39;</code></a> events would start emitting immediately. If you needed to do
some I/O to decide how to handle data, then you had to store the chunks
in some kind of buffer so that they would not be lost.</li>
<li>The <a href="#stream_readable_pause"><code class="prettyprint">stream.pause()</code></a> method was advisory, rather than
guaranteed. This meant that you still had to be prepared to receive
<a href="#stream_event_data"><code class="prettyprint">&#39;data&#39;</code></a> events even when the stream was in a paused state.</li>
</ul>

<p>In Node.js v0.10, the <a href="#stream_class_stream_readable">Readable</a> class was added.
For backwards compatibility with older Node.js programs, Readable streams
switch into &ldquo;flowing mode&rdquo; when a <a href="#stream_event_data"><code class="prettyprint">&#39;data&#39;</code></a> event handler is added, or
when the <a href="#stream_readable_resume"><code class="prettyprint">stream.resume()</code></a> method is called. The effect is
that, even if you are not using the new <a href="#stream_readable_read_size"><code class="prettyprint">stream.read()</code></a> method
and <a href="#stream_event_readable"><code class="prettyprint">&#39;readable&#39;</code></a> event, you no longer have to worry about losing
<a href="#stream_event_data"><code class="prettyprint">&#39;data&#39;</code></a> chunks.</p>

<p>Most programs will continue to function normally. However, this
introduces an edge case in the following conditions:</p>

<ul>
<li>No <a href="#stream_event_data"><code class="prettyprint">&#39;data&#39;</code></a> event handler is added.</li>
<li>The <a href="#stream_readable_resume"><code class="prettyprint">stream.resume()</code></a> method is never called.</li>
<li>The stream is not piped to any writable destination.</li>
</ul>

<p>For example, consider the following code:</p>
<pre class="highlight javascript"><code><span class="c1">// WARNING!  BROKEN!</span>
<span class="nx">net</span><span class="p">.</span><span class="nx">createServer</span><span class="p">((</span><span class="nx">socket</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>

  <span class="c1">// we add an 'end' method, but never consume the data</span>
  <span class="nx">socket</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'end'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// It will never get here.</span>
    <span class="nx">socket</span><span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="s1">'I got your message (but didnt read it)\n'</span><span class="p">);</span>
  <span class="p">});</span>

<span class="p">}).</span><span class="nx">listen</span><span class="p">(</span><span class="mi">1337</span><span class="p">);</span>
</code></pre>

<p>In versions of Node.js prior to v0.10, the incoming message data would be
simply discarded. However, in Node.js v0.10 and beyond,
the socket will remain paused forever.</p>

<p>The workaround in this situation is to call the
<a href="#stream_readable_resume"><code class="prettyprint">stream.resume()</code></a> method to start the flow of data:</p>
<pre class="highlight javascript"><code><span class="c1">// Workaround</span>
<span class="nx">net</span><span class="p">.</span><span class="nx">createServer</span><span class="p">((</span><span class="nx">socket</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>

  <span class="nx">socket</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'end'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">socket</span><span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="s1">'I got your message (but didnt read it)\n'</span><span class="p">);</span>
  <span class="p">});</span>

  <span class="c1">// start the flow of data, discarding it.</span>
  <span class="nx">socket</span><span class="p">.</span><span class="nx">resume</span><span class="p">();</span>

<span class="p">}).</span><span class="nx">listen</span><span class="p">(</span><span class="mi">1337</span><span class="p">);</span>
</code></pre>

<p>In addition to new Readable streams switching into flowing mode,
pre-v0.10 style streams can be wrapped in a Readable class using the
<a href="#stream_readable_wrap_stream"><code class="prettyprint">stream.wrap()</code></a> method.</p>

<h3 id="object-mode">Object Mode</h3>

<!--type=misc-->

<p>Normally, Streams operate on Strings and Buffers exclusively.</p>

<p>Streams that are in <strong>object mode</strong> can emit generic JavaScript values
other than Buffers and Strings.</p>

<p>A Readable stream in object mode will always return a single item from
a call to <a href="#stream_readable_read_size"><code class="prettyprint">stream.read(size)</code></a>, regardless of what the size
argument is.</p>

<p>A Writable stream in object mode will always ignore the <code class="prettyprint">encoding</code>
argument to <a href="#stream_writable_write_chunk_encoding_callback"><code class="prettyprint">stream.write(data, encoding)</code></a>.</p>

<p>The special value <code class="prettyprint">null</code> still retains its special value for object
mode streams. That is, for object mode readable streams, <code class="prettyprint">null</code> as a
return value from <a href="#stream_readable_read_size"><code class="prettyprint">stream.read()</code></a> indicates that there is no more
data, and <a href="#stream_readable_push_chunk_encoding"><code class="prettyprint">stream.push(null)</code></a> will signal the end of stream data
(<code class="prettyprint">EOF</code>).</p>

<p>No streams in Node.js core are object mode streams. This pattern is only
used by userland streaming libraries.</p>

<p>You should set <code class="prettyprint">objectMode</code> in your stream child class constructor on
the options object. Setting <code class="prettyprint">objectMode</code> mid-stream is not safe.</p>

<p>For Duplex streams <code class="prettyprint">objectMode</code> can be set exclusively for readable or
writable side with <code class="prettyprint">readableObjectMode</code> and <code class="prettyprint">writableObjectMode</code>
respectively. These options can be used to implement parsers and
serializers with Transform streams.</p>
<pre class="highlight javascript"><code><span class="kr">const</span> <span class="nx">util</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'util'</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">StringDecoder</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'string_decoder'</span><span class="p">).</span><span class="nx">StringDecoder</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">Transform</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'stream'</span><span class="p">).</span><span class="nx">Transform</span><span class="p">;</span>
<span class="nx">util</span><span class="p">.</span><span class="nx">inherits</span><span class="p">(</span><span class="nx">JSONParseStream</span><span class="p">,</span> <span class="nx">Transform</span><span class="p">);</span>

<span class="c1">// Gets \n-delimited JSON string data, and emits the parsed objects</span>
<span class="kd">function</span> <span class="nx">JSONParseStream</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="k">this</span> <span class="k">instanceof</span> <span class="nx">JSONParseStream</span><span class="p">))</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">JSONParseStream</span><span class="p">();</span>

  <span class="nx">Transform</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="p">{</span> <span class="na">readableObjectMode</span> <span class="p">:</span> <span class="kc">true</span> <span class="p">});</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">_buffer</span> <span class="o">=</span> <span class="s1">''</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_decoder</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">StringDecoder</span><span class="p">(</span><span class="s1">'utf8'</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">JSONParseStream</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">_transform</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">chunk</span><span class="p">,</span> <span class="nx">encoding</span><span class="p">,</span> <span class="nx">cb</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_buffer</span> <span class="o">+=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_decoder</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="nx">chunk</span><span class="p">);</span>
  <span class="c1">// split on newlines</span>
  <span class="kd">var</span> <span class="nx">lines</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_buffer</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="sr">/</span><span class="se">\r?\n</span><span class="sr">/</span><span class="p">);</span>
  <span class="c1">// keep the last partial line buffered</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_buffer</span> <span class="o">=</span> <span class="nx">lines</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">l</span> <span class="o">&lt;</span> <span class="nx">lines</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">l</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">line</span> <span class="o">=</span> <span class="nx">lines</span><span class="p">[</span><span class="nx">l</span><span class="p">];</span>
    <span class="k">try</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">line</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">er</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="s1">'error'</span><span class="p">,</span> <span class="nx">er</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// push the parsed object out to the readable consumer</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">cb</span><span class="p">();</span>
<span class="p">};</span>

<span class="nx">JSONParseStream</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">_flush</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">cb</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Just handle any leftover</span>
  <span class="kd">var</span> <span class="nx">rem</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_buffer</span><span class="p">.</span><span class="nx">trim</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">rem</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">rem</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">er</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="s1">'error'</span><span class="p">,</span> <span class="nx">er</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// push the parsed object out to the readable consumer</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">cb</span><span class="p">();</span>
<span class="p">};</span>
</code></pre>

<h3 id="stream-read-0"><code class="prettyprint">stream.read(0)</code></h3>

<p>There are some cases where you want to trigger a refresh of the
underlying readable stream mechanisms, without actually consuming any
data. In that case, you can call <code class="prettyprint">stream.read(0)</code>, which will always
return null.</p>

<p>If the internal read buffer is below the <code class="prettyprint">highWaterMark</code>, and the
stream is not currently reading, then calling <code class="prettyprint">stream.read(0)</code> will trigger
a low-level <a href="#stream_readable_read_size_1"><code class="prettyprint">stream._read()</code></a> call.</p>

<p>There is almost never a need to do this. However, you will see some
cases in Node.js&rsquo;s internals where this is done, particularly in the
Readable stream class internals.</p>

<h3 id="stream-push-39-39"><code class="prettyprint">stream.push(&#39;&#39;)</code></h3>

<p>Pushing a zero-byte string or Buffer (when not in <a href="#stream_object_mode">Object mode</a>) has an
interesting side effect. Because it <em>is</em> a call to
<a href="#stream_readable_push_chunk_encoding"><code class="prettyprint">stream.push()</code></a>, it will end the <code class="prettyprint">reading</code> process. However, it
does <em>not</em> add any data to the readable buffer, so there&rsquo;s nothing for
a user to consume.</p>

<p>Very rarely, there are cases where you have no data to provide now,
but the consumer of your stream (or, perhaps, another bit of your own
code) will know when to check again, by calling <a href="#stream_readable_read_size"><code class="prettyprint">stream.read(0)</code></a>.
In those cases, you <em>may</em> call <code class="prettyprint">stream.push(&#39;&#39;)</code>.</p>

<p>So far, the only use case for this functionality is in the
<a href="https://nodejs.org/docs/v5.8.0/api/tls.html#tls_class_cryptostream"><code class="prettyprint">tls.CryptoStream</code></a> class, which is deprecated in Node.js/io.js v1.0. If you
find that you have to use <code class="prettyprint">stream.push(&#39;&#39;)</code>, please consider another
approach, because it almost certainly indicates that something is
horribly wrong.</p>
