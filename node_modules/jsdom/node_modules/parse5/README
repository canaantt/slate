<p align="center">
  <img src="https://raw.github.com/inikulin/parse5/master/logo.png" alt="parse5" />
</p>

<p><a href="https://travis-ci.org/inikulin/parse5"><img alt="Build Status" src="https://api.travis-ci.org/inikulin/parse5.svg" /></a>
<a href="https://www.npmjs.com/package/parse5"><img alt="npm" src="https://img.shields.io/npm/v/parse5.svg" /></a></p>

<p><em>WHATWG HTML5 specification-compliant, fast and ready for production HTML parsing/serialization toolset for Node and io.js.</em></p>

<p>I needed fast and ready for production HTML parser, which will parse HTML as a modern browser&rsquo;s parser.
Existing solutions were either too slow or their output was too inaccurate. So, this is how parse5 was born.</p>

<p><strong>Included tools:</strong>
*   <a href="#class-parser">Parser</a> - HTML to DOM-tree parser.
*   <a href="#class-simpleapiparser">SimpleApiParser</a> - <a href="http://en.wikipedia.org/wiki/Simple_API_for_XML">SAX</a>-style parser for HTML.
*   <a href="#class-serializer">Serializer</a> - DOM-tree to HTML code serializer.</p>

<h2 id="install">Install</h2>
<pre class="highlight plaintext"><code>$ npm install parse5
</code></pre>

<h2 id="usage">Usage</h2>
<pre class="highlight javascript"><code><span class="kd">var</span> <span class="nx">Parser</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'parse5'</span><span class="p">).</span><span class="nx">Parser</span><span class="p">;</span>

<span class="c1">//Instantiate parser</span>
<span class="kd">var</span> <span class="nx">parser</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Parser</span><span class="p">();</span>

<span class="c1">//Then feed it with an HTML document</span>
<span class="kd">var</span> <span class="nb">document</span> <span class="o">=</span> <span class="nx">parser</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="s1">'&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;Hi there!&lt;/body&gt;&lt;/html&gt;'</span><span class="p">)</span>

<span class="c1">//Now let's parse HTML-snippet</span>
<span class="kd">var</span> <span class="nx">fragment</span> <span class="o">=</span> <span class="nx">parser</span><span class="p">.</span><span class="nx">parseFragment</span><span class="p">(</span><span class="s1">'&lt;title&gt;Parse5 is &amp;#102;&amp;#117;&amp;#99;&amp;#107;ing awesome!&lt;/title&gt;&lt;h1&gt;42&lt;/h1&gt;'</span><span class="p">);</span>

</code></pre>

<h2 id="is-it-fast">Is it fast?</h2>

<p>Check out <a href="https://github.com/inikulin/node-html-parser-bench">this benchmark</a>.</p>
<pre class="highlight plaintext"><code>Starting benchmark. Fasten your seatbelts...
html5 (https://github.com/aredridel/html5) x 0.18 ops/sec ±5.92% (5 runs sampled)
htmlparser (https://github.com/tautologistics/node-htmlparser/) x 3.83 ops/sec ±42.43% (14 runs sampled)
htmlparser2 (https://github.com/fb55/htmlparser2) x 4.05 ops/sec ±39.27% (15 runs sampled)
parse5 (https://github.com/inikulin/parse5) x 3.04 ops/sec ±51.81% (13 runs sampled)
Fastest is htmlparser2 (https://github.com/fb55/htmlparser2),parse5 (https://github.com/inikulin/parse5)
</code></pre>

<p>So, parse5 is as fast as simple specification incompatible parsers and ~15-times(!) faster than the current specification compatible parser available for the node.</p>

<h2 id="api-reference">API reference</h2>

<h3 id="enum-treeadapters">Enum: TreeAdapters</h3>

<p>Provides built-in tree adapters which can be passed as an optional argument to the <code class="prettyprint">Parser</code> and <code class="prettyprint">Serializer</code> constructors.</p>

<h4 id="bull-treeadapters-default">&bull; TreeAdapters.default</h4>

<p>Default tree format for parse5.</p>

<h4 id="bull-treeadapters-htmlparser2">&bull; TreeAdapters.htmlparser2</h4>

<p>Quite popular <a href="https://github.com/fb55/htmlparser2">htmlparser2</a> tree format (e.g. used in <a href="https://github.com/MatthewMueller/cheerio">cheerio</a> and <a href="https://github.com/tmpvar/jsdom">jsdom</a>).</p>

<hr>

<h3 id="class-parser">Class: Parser</h3>

<p>Provides HTML parsing functionality.</p>

<h4 id="bull-parser-ctor-treeadapter-options">&bull; Parser.ctor([treeAdapter, options])</h4>

<p>Creates new reusable instance of the <code class="prettyprint">Parser</code>. Optional <code class="prettyprint">treeAdapter</code> argument specifies resulting tree format. If <code class="prettyprint">treeAdapter</code> argument is not specified, <code class="prettyprint">default</code> tree adapter will be used.</p>

<p><code class="prettyprint">options</code> object provides the parsing algorithm modifications:</p>

<h5 id="options-decodehtmlentities">options.decodeHtmlEntities</h5>

<p>Decode HTML-entities like <code class="prettyprint">&amp;amp;</code>, <code class="prettyprint">&amp;nbsp;</code>, etc.  Default: <code class="prettyprint">true</code>. <strong>Warning:</strong> disabling this option may cause output which is not conform HTML5 specification.</p>

<h5 id="options-locationinfo">options.locationInfo</h5>

<p>Enables source code location information for the nodes. Default: <code class="prettyprint">false</code>. When enabled, each node (except root node) has <code class="prettyprint">__location</code> property, which contains <code class="prettyprint">start</code> and <code class="prettyprint">end</code> indices of the node in the source code. If element was implicitly created by the parser it&rsquo;s <code class="prettyprint">__location</code> property will be <code class="prettyprint">null</code>. In case the node is not an empty element, <code class="prettyprint">__location</code> has two addition properties <code class="prettyprint">startTag</code> and <code class="prettyprint">endTag</code> which contain location information for individual tags in a fashion similar to <code class="prettyprint">__location</code> property.</p>

<p><em>Example:</em>
&ldquo;`js
var parse5 = require(&lsquo;parse5&rsquo;);</p>

<p>//Instantiate new parser with default tree adapter
var parser1 = new parse5.Parser();</p>

<p>//Instantiate new parser with htmlparser2 tree adapter
var parser2 = new parse5.Parser(parse5.TreeAdapters.htmlparser2);
&rdquo;`</p>

<h4 id="bull-parser-parse-html">&bull; Parser.parse(html)</h4>

<p>Parses specified <code class="prettyprint">html</code> string. Returns <code class="prettyprint">document</code> node.</p>

<p><em>Example:</em>
<code class="prettyprint">js
var document = parser.parse(&#39;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;Hi there!&lt;/body&gt;&lt;/html&gt;&#39;);
</code></p>

<h4 id="bull-parser-parsefragment-htmlfragment-contextelement">&bull; Parser.parseFragment(htmlFragment, [contextElement])</h4>

<p>Parses given <code class="prettyprint">htmlFragment</code>. Returns <code class="prettyprint">documentFragment</code> node. Optional <code class="prettyprint">contextElement</code> argument specifies context in which given <code class="prettyprint">htmlFragment</code> will be parsed (consider it as setting <code class="prettyprint">contextElement.innerHTML</code> property). If <code class="prettyprint">contextElement</code> argument is not specified then <code class="prettyprint">&lt;template&gt;</code> element will be used as a context and fragment will be parsed in &#39;forgiving&rsquo; manner.</p>

<p><em>Example:</em>
&ldquo;`js
var documentFragment = parser.parseFragment(&rsquo;<table></table>&rsquo;);</p>

<p>//Parse html fragment in context of the parsed <table> element
var trFragment = parser.parseFragment(&rsquo;<tr><td>Shake it, baby</td></tr>&rsquo;, documentFragment.childNodes[0]);
&rdquo;`</p>

<hr>

<h3 id="class-simpleapiparser">Class: SimpleApiParser</h3>

<p>Provides <a href="https://en.wikipedia.org/wiki/Simple_API_for_XML">SAX</a>-style HTML parsing functionality.</p>

<h4 id="bull-simpleapiparser-ctor-handlers-options">&bull; SimpleApiParser.ctor(handlers, [options])</h4>

<p>Creates new reusable instance of the <code class="prettyprint">SimpleApiParser</code>. <code class="prettyprint">handlers</code> argument specifies object that contains parser&rsquo;s event handlers. Possible events and their signatures are shown in the example.</p>

<p><code class="prettyprint">options</code> object provides the parsing algorithm modifications:</p>

<h5 id="options-decodehtmlentities">options.decodeHtmlEntities</h5>

<p>Decode HTML-entities like <code class="prettyprint">&amp;amp;</code>, <code class="prettyprint">&amp;nbsp;</code>, etc.  Default: <code class="prettyprint">true</code>. <strong>Warning:</strong> disabling this option may cause output which is not conform HTML5 specification.</p>

<h5 id="options-locationinfo">options.locationInfo</h5>

<p>Enables source code location information for the tokens. Default: <code class="prettyprint">false</code>. When enabled, each node handler receives <code class="prettyprint">location</code> object as it&rsquo;s last argument. <code class="prettyprint">location</code> object contains <code class="prettyprint">start</code> and <code class="prettyprint">end</code> indices of the token in the source code.</p>

<p><em>Example:</em>
&ldquo;`js
var parse5 = require(&#39;parse5&rsquo;);</p>

<p>var parser = new parse5.SimpleApiParser({
    doctype: function(name, publicId, systemId /*, [location] */) {
        //Handle doctype here
    },</p>

<p>startTag: function(tagName, attrs, selfClosing /*, [location] */) {
        //Handle start tags here
    },</p>

<p>endTag: function(tagName /*, [location] */) {
        //Handle end tags here
    },</p>

<p>text: function(text /*, [location] */) {
        //Handle texts here
    },</p>

<p>comment: function(text /*, [location] */) {
        //Handle comments here
    }
});
&rdquo;`</p>

<h4 id="bull-simpleapiparser-parse-html">&bull; SimpleApiParser.parse(html)</h4>

<p>Raises parser events for the given <code class="prettyprint">html</code>.</p>

<p><em>Example:</em>
&ldquo;`js
var parse5 = require(&#39;parse5&rsquo;);</p>

<p>var parser = new parse5.SimpleApiParser({
    text: function(text) {
        console.log(text);
    }
});</p>

<p>parser.parse(&rsquo;<body>Yo!</body>&rsquo;);
&rdquo;`</p>

<hr>

<h3 id="class-serializer">Class: Serializer</h3>

<p>Provides tree-to-HTML serialization functionality.
<strong>Note:</strong> prior to v1.2.0 this class was called <code class="prettyprint">TreeSerializer</code>. However, it&rsquo;s still accessible as <code class="prettyprint">parse5.TreeSerializer</code> for backward compatibility.</p>

<h4 id="bull-serializer-ctor-treeadapter-options">&bull; Serializer.ctor([treeAdapter, options])</h4>

<p>Creates new reusable instance of the <code class="prettyprint">Serializer</code>. Optional <code class="prettyprint">treeAdapter</code> argument specifies input tree format. If <code class="prettyprint">treeAdapter</code> argument is not specified, <code class="prettyprint">default</code> tree adapter will be used.</p>

<p><code class="prettyprint">options</code> object provides the serialization algorithm modifications:</p>

<h5 id="options-encodehtmlentities">options.encodeHtmlEntities</h5>

<p>HTML-encode characters like <code class="prettyprint">&lt;</code>, <code class="prettyprint">&gt;</code>, <code class="prettyprint">&amp;</code>, etc.  Default: <code class="prettyprint">true</code>.  <strong>Warning:</strong> disabling this option may cause output which is not conform HTML5 specification.</p>

<p><em>Example:</em>
&ldquo;`js
var parse5 = require(&#39;parse5&rsquo;);</p>

<p>//Instantiate new serializer with default tree adapter
var serializer1 = new parse5.Serializer();</p>

<p>//Instantiate new serializer with htmlparser2 tree adapter
var serializer2 = new parse5.Serializer(parse5.TreeAdapters.htmlparser2);
&rdquo;`</p>

<h4 id="bull-serializer-serialize-node">&bull; Serializer.serialize(node)</h4>

<p>Serializes the given <code class="prettyprint">node</code>. Returns HTML string.</p>

<p><em>Example:</em>
&ldquo;`js
var document = parser.parse(&rsquo;&lt;!DOCTYPE html&gt;<html><head></head><body>Hi there!</body></html>&rsquo;);</p>

<p>//Serialize document
var html = serializer.serialize(document);</p>

<p>//Serialize <body> element content
var bodyInnerHtml = serializer.serialize(document.childNodes[0].childNodes[1]);
&rdquo;`</p>

<hr>

<h2 id="testing">Testing</h2>

<p>Test data is adopted from <a href="https://github.com/html5lib">html5lib project</a>. Parser is covered by more than 8000 test cases.
To run tests:
<code class="prettyprint">
$ npm test
</code></p>

<h2 id="custom-tree-adapter">Custom tree adapter</h2>

<p>You can create a custom tree adapter so parse5 can work with your own DOM-tree implementation.
Just pass your adapter implementation to the parser&rsquo;s constructor as an argument:</p>
<pre class="highlight javascript"><code><span class="kd">var</span> <span class="nx">Parser</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'parse5'</span><span class="p">).</span><span class="nx">Parser</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">myTreeAdapter</span> <span class="o">=</span> <span class="p">{</span>
   <span class="c1">//Adapter methods...</span>
<span class="p">};</span>

<span class="c1">//Instantiate parser</span>
<span class="kd">var</span> <span class="nx">parser</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Parser</span><span class="p">(</span><span class="nx">myTreeAdapter</span><span class="p">);</span>
</code></pre>

<p>Sample implementation can be found <a href="https://github.com/inikulin/parse5/blob/master/lib/tree_adapters/default.js">here</a>.
The custom tree adapter should implement all methods exposed via <code class="prettyprint">exports</code> in the sample implementation.</p>

<h2 id="questions-or-suggestions">Questions or suggestions?</h2>

<p>If you have any questions, please feel free to create an issue <a href="https://github.com/inikulin/parse5/issues">here on github</a>.</p>

<h2 id="author">Author</h2>

<p><a href="https://github.com/inikulin">Ivan Nikulin</a> (ifaaan@gmail.com)</p>
