<h1 id="webidl-type-conversions-on-javascript-values">WebIDL Type Conversions on JavaScript Values</h1>

<p>This package implements, in JavaScript, the algorithms to convert a given JavaScript value according to a given <a href="http://heycam.github.io/webidl/">WebIDL</a> <a href="http://heycam.github.io/webidl/#idl-types">type</a>.</p>

<p>The goal is that you should be able to write code like</p>
<pre class="highlight javascript"><code><span class="kr">const</span> <span class="nx">conversions</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">"webidl-conversions"</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">doStuff</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">x</span> <span class="o">=</span> <span class="nx">conversions</span><span class="p">[</span><span class="s2">"boolean"</span><span class="p">](</span><span class="nx">x</span><span class="p">);</span>
    <span class="nx">y</span> <span class="o">=</span> <span class="nx">conversions</span><span class="p">[</span><span class="s2">"unsigned long"</span><span class="p">](</span><span class="nx">y</span><span class="p">);</span>
    <span class="c1">// actual algorithm code here</span>
<span class="p">}</span>
</code></pre>

<p>and your function <code class="prettyprint">doStuff</code> will behave the same as a WebIDL operation declared as</p>
<pre class="highlight plaintext"><code>void doStuff(boolean x, unsigned long y);
</code></pre>

<h2 id="api">API</h2>

<p>This package&rsquo;s main module&rsquo;s default export is an object with a variety of methods, each corresponding to a different WebIDL type. Each method, when invoked on a JavaScript value, will give back the new JavaScript value that results after passing through the WebIDL conversion rules. (See below for more details on what that means.) Alternately, the method could throw an error, if the WebIDL algorithm is specified to do so: for example <code class="prettyprint">conversions[&quot;float&quot;](NaN)</code> <a href="http://heycam.github.io/webidl/#es-float">will throw a <code class="prettyprint">TypeError</code></a>.</p>

<h2 id="status">Status</h2>

<p>All of the numeric types are implemented (float being implemented as double) and some others are as well - check the source for all of them. This list will grow over time in service of the <a href="https://github.com/dglazkov/html-as-custom-elements">HTML as Custom Elements</a> project, but in the meantime, pull requests welcome!</p>

<p>I&rsquo;m not sure yet what the strategy will be for modifiers, e.g. <a href="http://heycam.github.io/webidl/#Clamp"><code class="prettyprint">[Clamp]</code></a>. Maybe something like <code class="prettyprint">conversions[&quot;unsigned long&quot;](x, { clamp: true })</code>? We&rsquo;ll see.</p>

<p>We might also want to extend the API to give better error messages, e.g. &ldquo;Argument 1 of HTMLMediaElement.fastSeek is not a finite floating-point value&rdquo; instead of &ldquo;Argument is not a finite floating-point value.&rdquo; This would require passing in more information to the conversion functions than we currently do.</p>

<h2 id="background">Background</h2>

<p>What&rsquo;s actually going on here, conceptually, is pretty weird. Let&rsquo;s try to explain.</p>

<p>WebIDL, as part of its madness-inducing design, has its own type system. When people write algorithms in web platform specs, they usually operate on WebIDL values, i.e. instances of WebIDL types. For example, if they were specifying the algorithm for our <code class="prettyprint">doStuff</code> operation above, they would treat <code class="prettyprint">x</code> as a WebIDL value of <a href="http://heycam.github.io/webidl/#idl-boolean">WebIDL type <code class="prettyprint">boolean</code></a>. Crucially, they would <em>not</em> treat <code class="prettyprint">x</code> as a JavaScript variable whose value is either the JavaScript <code class="prettyprint">true</code> or <code class="prettyprint">false</code>. They&rsquo;re instead working in a different type system altogether, with its own rules.</p>

<p>Separately from its type system, WebIDL defines a <a href="http://heycam.github.io/webidl/#ecmascript-binding">&ldquo;binding&rdquo;</a> of the type system into JavaScript. This contains rules like: when you pass a JavaScript value to the JavaScript method that manifests a given WebIDL operation, how does that get converted into a WebIDL value? For example, a JavaScript <code class="prettyprint">true</code> passed in the position of a WebIDL <code class="prettyprint">boolean</code> argument becomes a WebIDL <code class="prettyprint">true</code>. But, a JavaScript <code class="prettyprint">true</code> passed in the position of a <a href="http://heycam.github.io/webidl/#idl-unsigned-long">WebIDL <code class="prettyprint">unsigned long</code></a> becomes a WebIDL <code class="prettyprint">1</code>. And so on.</p>

<p>Finally, we have the actual implementation code. This is usually C++, although these days <a href="https://github.com/servo/servo">some smart people are using Rust</a>. The implementation, of course, has its own type system. So when they implement the WebIDL algorithms, they don&rsquo;t actually use WebIDL values, since those aren&rsquo;t &ldquo;real&rdquo; outside of specs. Instead, implementations apply the WebIDL binding rules in such a way as to convert incoming JavaScript values into C++ values. For example, if code in the browser called <code class="prettyprint">doStuff(true, true)</code>, then the implementation code would eventually receive a C++ <code class="prettyprint">bool</code> containing <code class="prettyprint">true</code> and a C++ <code class="prettyprint">uint32_t</code> containing <code class="prettyprint">1</code>.</p>

<p>The upside of all this is that implementations can abstract all the conversion logic away, letting WebIDL handle it, and focus on implementing the relevant methods in C++ with values of the correct type already provided. That is payoff of WebIDL, in a nutshell.</p>

<p>And getting to that payoff is the goal of <em>this</em> project—but for JavaScript implementations, instead of C++ ones. That is, this library is designed to make it easier for JavaScript developers to write functions that behave like a given WebIDL operation. So conceptually, the conversion pipeline, which in its general form is JavaScript values ↦ WebIDL values ↦ implementation-language values, in this case becomes JavaScript values ↦ WebIDL values ↦ JavaScript values. And that intermediate step is where all the logic is performed: a JavaScript <code class="prettyprint">true</code> becomes a WebIDL <code class="prettyprint">1</code> in an unsigned long context, which then becomes a JavaScript <code class="prettyprint">1</code>.</p>

<h2 id="don-39-t-use-this">Don&rsquo;t Use This</h2>

<p>Seriously, why would you ever use this? You really shouldn&rsquo;t. WebIDL is … not great, and you shouldn&rsquo;t be emulating its semantics. If you&rsquo;re looking for a generic argument-processing library, you should find one with better rules than those from WebIDL. In general, your JavaScript should not be trying to become more like WebIDL; if anything, we should fix WebIDL to make it more like JavaScript.</p>

<p>The <em>only</em> people who should use this are those trying to create faithful implementations (or polyfills) of web platform interfaces defined in WebIDL.</p>
