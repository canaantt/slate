var hooks=require("./hooks"),should=require("should"),assert=require("assert"),_=require("underscore");module.exports={"should be able to assign multiple hooks at once":function(){var e=function(){};_.extend(e,hooks),e.hook({hook1:function(e){},hook2:function(e){}});var o=new e;assert.equal(typeof o.hook1,"function"),assert.equal(typeof o.hook2,"function")},"should run without pres and posts when not present":function(){var e=function(){};_.extend(e,hooks),e.hook("save",function(){this.value=1});var o=new e;o.save(),o.value.should.equal(1)},"should run with pres when present":function(){var e=function(){};_.extend(e,hooks),e.hook("save",function(){this.value=1}),e.pre("save",function(e){this.preValue=2,e()});var o=new e;o.save(),o.value.should.equal(1),o.preValue.should.equal(2)},"should run with posts when present":function(){var e=function(){};_.extend(e,hooks),e.hook("save",function(){this.value=1}),e.post("save",function(e){this.value=2,e()});var o=new e;o.save(),o.value.should.equal(2)},"should run pres and posts when present":function(){var e=function(){};_.extend(e,hooks),e.hook("save",function(){this.value=1}),e.pre("save",function(e){this.preValue=2,e()}),e.post("save",function(e){this.value=3,e()});var o=new e;o.save(),o.value.should.equal(3),o.preValue.should.equal(2)},"should run posts after pres":function(){var e=function(){};_.extend(e,hooks),e.hook("save",function(){this.value=1}),e.pre("save",function(e){this.override=100,e()}),e.post("save",function(e){this.override=200,e()});var o=new e;o.save(),o.value.should.equal(1),o.override.should.equal(200)},"should not run a hook if a pre fails":function(){var e=function(){};_.extend(e,hooks);var o=0;e.hook("save",function(){this.value=1},function(e){o++}),e.pre("save",!0,function(e,o){e(new Error)});var n=new e;n.save(),o.should.equal(1),assert.equal(typeof n.value,"undefined")},"should be able to run multiple pres":function(){var e=function(){};_.extend(e,hooks),e.hook("save",function(){this.value=1}),e.pre("save",function(e){this.v1=1,e()}).pre("save",function(e){this.v2=2,e()});var o=new e;o.save(),o.v1.should.equal(1),o.v2.should.equal(2)},"should run multiple pres until a pre fails and not call the hook":function(){var e=function(){};_.extend(e,hooks),e.hook("save",function(){this.value=1},function(e){}),e.pre("save",function(e){this.v1=1,e()}).pre("save",function(e){e(new Error)}).pre("save",function(e){this.v3=3,e()});var o=new e;o.save(),o.v1.should.equal(1),assert.equal(typeof o.v3,"undefined"),assert.equal(typeof o.value,"undefined")},"should be able to run multiple posts":function(){var e=function(){};_.extend(e,hooks),e.hook("save",function(){this.value=1}),e.post("save",function(e){this.value=2,e()}).post("save",function(e){this.value=3.14,e()}).post("save",function(e){this.v3=3,e()});var o=new e;o.save(),assert.equal(o.value,3.14),assert.equal(o.v3,3)},"should run only posts up until an error":function(){var e=function(){};_.extend(e,hooks),e.hook("save",function(){this.value=1},function(e){}),e.post("save",function(e){this.value=2,e()}).post("save",function(e){this.value=3,e(new Error)}).post("save",function(e){this.value=4,e()});var o=new e;o.save(),o.value.should.equal(3)},"should fall back first to the hook method's last argument as the error handler if it is a function of arity 1 or 2":function(){var e=function(){};_.extend(e,hooks);var o=0;e.hook("save",function(e){this.value=1}),e.pre("save",!0,function(e,o){e(new Error)});var n=new e;n.save(function(e){e instanceof Error&&o++}),o.should.equal(1),should.deepEqual(void 0,n.value)},"should fall back second to the default error handler if specified":function(){var e=function(){};_.extend(e,hooks);var o=0;e.hook("save",function(e){this.value=1},function(e){e instanceof Error&&o++}),e.pre("save",!0,function(e,o){e(new Error)});var n=new e;n.save(),o.should.equal(1),should.deepEqual(void 0,n.value)},"fallback default error handler should scope to the object":function(){var e=function(){this.counter=0};_.extend(e,hooks);e.hook("save",function(e){this.value=1},function(e){e instanceof Error&&this.counter++}),e.pre("save",!0,function(e,o){e(new Error)});var o=new e;o.save(),o.counter.should.equal(1),should.deepEqual(void 0,o.value)},"should fall back last to throwing the error":function(){var e=function(){};_.extend(e,hooks);var o=0;e.hook("save",function(e){return e instanceof Error?o++:void(this.value=1)}),e.pre("save",!0,function(e,o){e(new Error)});var n=new e,t=!1;try{n.save()}catch(s){t=!0,s.should.be.an["instanceof"](Error),o.should.equal(0),assert.equal(typeof n.value,"undefined")}t.should.be["true"]},"should proceed without mutating arguments if `next(null|undefined)` is called in a serial pre, and the last argument of the target method is a callback with node-like signature function (err, obj) {...} or function (err) {...}":function(){var e=function(){};_.extend(e,hooks);var o=0;e.prototype.save=function(e){this.value=1,e()},e.pre("save",function(e){e(null)}),e.pre("save",function(e){e(void 0)});var n=new e;n.save(function(e){e instanceof Error?o++:o--}),o.should.equal(-1),n.value.should.eql(1)},"should proceed with mutating arguments if `next(null|undefined)` is callback in a serial pre, and the last argument of the target method is not a function":function(){var e=function(){};_.extend(e,hooks),e.prototype.set=function(e){this.value=e},e.pre("set",function(e){e(void 0)}),e.pre("set",function(e){e(null)});var o=new e;o.set(1),should.strictEqual(null,o.value)},"should not run any posts if a pre fails":function(){var e=function(){};_.extend(e,hooks),e.hook("save",function(){this.value=2},function(e){}),e.pre("save",function(e){this.value=1,e(new Error)}).post("save",function(e){this.value=3,e()});var o=new e;o.save(),o.value.should.equal(1)},"can pass the hook's arguments verbatim to pres":function(){var e=function(){};_.extend(e,hooks),e.hook("set",function(e,o){this[e]=o}),e.pre("set",function(e,o,n){o.should.equal("hello"),n.should.equal("world"),e()});var o=new e;o.set("hello","world"),o.hello.should.equal("world")},"can pass the hook's arguments verbatim to posts":function(){var e=function(){};_.extend(e,hooks),e.hook("set",function(e,o){this[e]=o}),e.post("set",function(e,o,n){o.should.equal("hello"),n.should.equal("world"),e()});var o=new e;o.set("hello","world"),assert.equal(o.hello,"world")},"pres should be able to modify and pass on a modified version of the hook's arguments":function(){var e=function(){};_.extend(e,hooks),e.hook("set",function(e,o){this[e]=o,assert.equal(arguments[2],"optional")}),e.pre("set",function(e,o,n){e("foo","bar")}),e.pre("set",function(e,o,n){assert.equal(o,"foo"),assert.equal(n,"bar"),e("rock","says","optional")}),e.pre("set",function(e,o,n,t){assert.equal(o,"rock"),assert.equal(n,"says"),assert.equal(t,"optional"),e()});var o=new e;o.set("hello","world"),assert.equal(typeof o.hello,"undefined"),o.rock.should.equal("says")},"posts should see the modified version of arguments if the pres modified them":function(){var e=function(){};_.extend(e,hooks),e.hook("set",function(e,o){this[e]=o}),e.pre("set",function(e,o,n){e("foo","bar")}),e.post("set",function(e,o,n){o.should.equal("foo"),n.should.equal("bar")});var o=new e;o.set("hello","world"),assert.equal(typeof o.hello,"undefined"),o.foo.should.equal("bar")},"should pad missing arguments (relative to expected arguments of the hook) with null":function(){var e=function(){};_.extend(e,hooks),e.hook("set",function(e,o,n){this[e]=o}),e.pre("set",function(e,o,n,t){e("foo","bar"),assert.equal(typeof t,"undefined")});var o=new e;o.set("hello","world")},"should not invoke the target method until all asynchronous middleware have invoked dones":function(){var e=0,o=function(){};_.extend(o,hooks),o.hook("set",function(o,n){e++,this[o]=n,e.should.equal(7)}),o.pre("set",function(o,n,t){e++,o()}),o.pre("set",!0,function(o,n,t,s){e++,setTimeout(function(){e++,n()},1e3),o()}),o.pre("set",function(o,n,t){e++,o()}),o.pre("set",!0,function(o,n,t,s){e++,setTimeout(function(){e++,n()},500),o()});var n=new o;n.set("hello","world")},"invoking a method twice should run its async middleware twice":function(){var e=0,o=function(){};_.extend(o,hooks),o.hook("set",function(o,n){this[o]=n,"hello"===o&&e.should.equal(1),"foo"===o&&e.should.equal(2)}),o.pre("set",!0,function(o,n,t,s){setTimeout(function(){e++,n()},1e3),o()});var n=new o;n.set("hello","world"),n.set("foo","bar")},"calling the same done multiple times should have the effect of only calling it once":function(){var e=function(){this.acked=!1};_.extend(e,hooks),e.hook("ack",function(){console.log("UH OH, YOU SHOULD NOT BE SEEING THIS"),this.acked=!0}),e.pre("ack",!0,function(e,o){e(),o(),o()}),e.pre("ack",!0,function(e,o){e()});var o=new e;o.ack(),setTimeout(function(){o.acked.should.be["false"]},1e3)},"calling the same next multiple times should have the effect of only calling it once":function(e){var o=function(){this.acked=!1};_.extend(o,hooks),o.hook("ack",function(){console.log("UH OH, YOU SHOULD NOT BE SEEING THIS"),this.acked=!0}),o.pre("ack",function(e){try{e(new Error("bam"))}catch(o){e()}}),o.pre("ack",function(e){e()});var n=new o;n.ack(),e(function(){n.acked.should.be["false"]})},"asynchronous middleware should be able to pass an error via `done`, stopping the middleware chain":function(){var e=0,o=function(){};_.extend(o,hooks),o.hook("set",function(o,n,t){e++,this[o]=n,t(null)}),o.pre("set",!0,function(o,n,t,s,a){setTimeout(function(){e++,n(new Error)},1e3),o()});var n=new o;n.set("hello","world",function(o){o.should.be.an["instanceof"](Error),should.strictEqual(void 0,n.hello),e.should.eql(1)})},"should be able to remove a particular pre":function(){var e,o=function(){};_.extend(o,hooks),o.hook("save",function(){this.value=1}),o.pre("save",function(e){this.preValueOne=2,e()}),o.pre("save",e=function(e){this.preValueTwo=4,e()}),o.removePre("save",e);var n=new o;n.save(),n.value.should.equal(1),n.preValueOne.should.equal(2),should.strictEqual(void 0,n.preValueTwo)},"should be able to remove all pres associated with a hook":function(){var e=function(){};_.extend(e,hooks),e.hook("save",function(){this.value=1}),e.pre("save",function(e){this.preValueOne=2,e()}),e.pre("save",function(e){this.preValueTwo=4,e()}),e.removePre("save");var o=new e;o.save(),o.value.should.equal(1),should.strictEqual(void 0,o.preValueOne),should.strictEqual(void 0,o.preValueTwo)},"should be able to remove a particular post":function(){var e,o=function(){};_.extend(o,hooks),o.hook("save",function(){this.value=1}),o.post("save",function(e){this.postValueOne=2,e()}),o.post("save",e=function(e){this.postValueTwo=4,e()}),o.removePost("save",e);var n=new o;n.save(),n.value.should.equal(1),n.postValueOne.should.equal(2),should.strictEqual(void 0,n.postValueTwo)},"should be able to remove all posts associated with a hook":function(){var e=function(){};_.extend(e,hooks),e.hook("save",function(){this.value=1}),e.post("save",function(e){this.postValueOne=2,e()}),e.post("save",function(e){this.postValueTwo=4,e()}),e.removePost("save");var o=new e;o.save(),o.value.should.equal(1),should.strictEqual(void 0,o.postValueOne),should.strictEqual(void 0,o.postValueTwo)},"#pre should lazily make a method hookable":function(){var e=function(){};_.extend(e,hooks),e.prototype.save=function(){this.value=1},e.pre("save",function(e){this.preValue=2,e()});var o=new e;o.save(),o.value.should.equal(1),o.preValue.should.equal(2)},"#pre lazily making a method hookable should be able to provide a default errorHandler as the last argument":function(){var e=function(){},o="";_.extend(e,hooks),e.prototype.save=function(){this.value=1},e.pre("save",function(e){e(new Error)},function(e){o="ERROR"});var n=new e;n.save(),should.strictEqual(void 0,n.value),o.should.equal("ERROR")},"#post should lazily make a method hookable":function(){var e=function(){};_.extend(e,hooks),e.prototype.save=function(){this.value=1},e.post("save",function(e){this.value=2,e()});var o=new e;o.save(),o.value.should.equal(2)},"a lazy hooks setup should handle errors via a method's last argument, if it's a callback":function(){var e=function(){};_.extend(e,hooks),e.prototype.save=function(e){},e.pre("save",function(e){e(new Error("hi there"))});var o=new e;o.save(function(e){e.should.be.an["instanceof"](Error)})},"should intercept method callbacks for post handlers":function(){var e=function(){};_.extend(e,hooks),e.hook("save",function(e,o){this.value=e,o()}),e.post("save",function(e){assert.equal(o.value,2),this.value+=2,setTimeout(e,10)}).post("save",function(e){assert.equal(o.value,4),this.value+=3,setTimeout(e,10)}).post("save",function(e){assert.equal(o.value,7),this.value2=3,setTimeout(e,10)});var o=new e;o.save(2,function(){assert.equal(o.value,7),assert.equal(o.value2,3)})},"should handle parallel followed by serial":function(){var e=function(){};_.extend(e,hooks),e.hook("save",function(e,o){this.value=e,o()}),e.pre("save",!0,function(e,o){process.nextTick(function(){o()}),e()}).pre("save",function(e){process.nextTick(function(){e()})});var o=new e;o.save(2,function(){assert.ok(!0)})}};